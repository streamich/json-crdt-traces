"# Introducing fast RGA implementation that will power JSON CRDTs\n\nFirst, a little note on JSON CRDT. JSON CRDT will be a specification and a JavaScript\nimplementation of JSON data type as a CRDT (Conflict-free Replicated Data Type). The\naim for JSON CRDT is to create a sound state-of-the-art CRDT specification which will\nsupport all JSON values, including lists, for which this RGA algorithm is needed.\n\nNow back to the RGA algorithm, what is that? RGA stands for [*Replicated Growable Array*][rga],\nalso known as CT ([*Causal Tree*][causal-tree]), sometimes you might find it abbreviated as CT/RGA. The\nCT/RGA algorithm, or RGA for short, allows to implement conflict free list data\nstructures, such as strings, binary blobs, or arrays (think JSON arrays).\n\nWhat is conflict-free, or CRDTs? Those are data types, which can be forked; then\ntwo or more peers can edit their copies independently and at any point in time all the\nforks can be merged back without conflicts. Also, forks can be merged in any order,\nwhich does not change the contents of the final document.\n\n\n## `json-joy` RGA implementation\n\nNow `json-joy` implements and advanced version of the RGA algorithm (we will take a look\nat it later what is advanced about it, but for now, just think about it as being very efficient\nand fast). Great news is that it is ready, and you can use it, lets see how it can be done.\n\nFirst, you will need to install the `json-joy` NPM package.\n\n```\nyarn add json-joy\n```\n\n`json-joy` implements an abstract version of the RGA algorithm in `AbstractRga` class, where\nelements can be of any type. But below we will take a look at application of it to a string\ndata type, which is implemented in the `StringRga` class.\n\nIn general, RGAs support two operations: (1) insert; and (2) delete. Lets see how to use those\nfor string editing.\n\nImport the `StringRga` class. Also, import the `ts` helper, which will allow us to create\n\"timestamps\" (aka *operation IDs*). All elements in RGA (and usually in all CRDTs, for that\nmatter) have a unique ID. We will need the `ts` helper to generate those IDs.\n\n```ts\nimport {StringRga} from 'json-joy/es2020/json-crdt/types/rga-string/StringRga';\nimport {ts} from 'json-joy/es2020/json-crdt-patch/clock';\n```\n\nDon't worry `StringRga` will not actually store an ID for every character, but more on that\nlater. IDs are 2-tuples of *Site ID* (aka *Process ID* or *Session ID*) and an ever\nincreasing sequence counter, i.e. \"time\"; essentially, and ID is a *Logical Timestamp*,\nwhere each user will have their own *Logical Clock*, and the collection nof all Logical Clocks\nof all users will for a *Vector Clock*.\n\nNow create the text CRDT data type, you will need to give it a unique ID:\n\n```ts\nconst sid = 123; // Site ID\nlet time = 0;  // \"time\"\n\nconst id = ts(sid, time++);\nconst str = new StringRga(id);\n```\n\nWe can see what is storied in our string using the `.view()` method, lets verify that\nit is empty:\n\n```ts\nconsole.log(str.view());\n// \"\"\n```\n\nWe can also print the internal state like so:\n\n```ts\nconsole.log(str + '');\n// StringRga 123.0 { \"\" }\n// └─ ∅\n```\n\nIt shows that the string has ID `123.0` and empty contents.\n\nNow lets insert somethign in to the string. A local insert can be performed using the\n`.insAt()` method.\n\n```ts\nlet content = 'Hell world!';\nstr.insAt(0, ts(sid, time), content);\ntime += content.length;\nconsole.log(str + '');\n// StringRga 123.0 { \"Hell world!\" }\n// └─ StringChunk 123.1!11 len:11 { \"Hell world!\" }\n```\n\nYou can see that a `StringChunk` was inserted, where `123.1!11` specifies the ID of\nthe first character of the chunk `123.1` and `!11` denotes the length of the chunk.\n\nLets perform another insert, to fix our text:\n\n```ts\ncontent = 'o,';\nstr.insAt(4, ts(sid, time), content);\ntime += content.length;\n\nconsole.log(str + '');\n// StringRga 123.0 { \"Hello, world!\" }\n// └─ StringChunk 123.12!2 len:13 { \"o,\" }\n//    ← StringChunk 123.1!4 len:4 { \"Hell\" }\n//    → StringChunk 123.5!7 len:7 { \" world!\" }\n\nconsole.log(str.view());\n// Hello, world!\n```\n\nYou can see we fixed the text to be `Hello, world!`, now you might also notice that\nthe string now has three `StringChunk` nodes arranged in a binary tree, where `←`\nand `→` represent the left and right children. More on that later, but that is the\nsecret source which makes the `json-joy` RGA implementation really fast: the text\nchunks follow what is known in academia *block-wise* storage, where chunks of text\nare stored in blocks with a small metadata piece allocated for each block, instead of\nstoring each character separately, with metadata allocated for each character. And\nbinary tree represents a custom [rope-like][rope] data structure, specifically\ndesigned for the RGA algorithm.\n\n[rope]: https://en.wikipedia.org/wiki/Rope_(data_structure)\n\nAll of this might sound overwhelming, but that is expected, you will not need to\nknow or use any of this; this is the lower-level (under-the-hood-workings) that will\npower the JSON CRDT implementation, for you&mdash;as a developer&mdash;it will be exposed\nin a nicely packaged API where you don't need to know anything about the inner workings\nof the CRDT algorithms.\n\nFor the sake of completeness, lets briefly take a look at other public methods that\nthe `StringRga` class exposes. Above I mentioned that RGA usually supports two operations;\ninsert and delete. That is true, but actually, in CRDTs, those are usually sub-divided\ninto *remote* and *local* operations. So, essentially `StringRga` supports four\nmain operations: (1) remote insert; (2) remote delete; (3) local insert; and (4) local\ndelete.\n\nWhat are those local vs remote operations? Local operations are the ones that user\nperforms on their machine, where operations contain the offset position in the text,\nfor example:\n\n- `insertAt(position, text)`\n- `deleteAt(position, length)`\n\nRemote operations are the ones received from other peers, and those don't reference the\nposition in text, instead they reference one or more IDs of the CRDT after which to\nperform the operation, for example:\n\n- `insert(afterId, text)`\n- `delete(...ids)`\n\nWe have already seen the local insert operation of the `StringRga`, it was `.insAt()`.\nNow lets take a look at the remote insert operation `.ins()`. It works similar to\n`.insAt()`, but instead of the insertion position, we will need to specify the ID of\nthe character after which we want to apply our insert.\n\nConsider we have three users: User 1 will create a new string `\"js\"`, then they will\nfork it and send the that string to two other users: (1) User 2 will insert `\"on\"` at\nthe end of it; (2) User 3 will concurrently (at the same time) insert `\" joy\"` at the\nsame position. Regardless in which order we apply the two remote operations of\nUser 2 and User 3, we will receive the same final result.\n\nLets create a new string `str1` with contents `\"js\"`, we will use the local `.insAt()`\nmethod to do that:\n\n```ts\nconst user1 = 123;\nconst user2 = 345;\nconst user3 = 789;\n\n// User 1 creates a new string\nconst str1 = new StringRga(ts(user1, 0));\nstr1.insAt(0, ts(user1, 1), 'js');\n```\n\nNothing new here, just one thing to note that the IDs of characters `j` and `s` will\nbe `123.1` and `123.2`, respectively. (And ID of the string is `123.0`.)\n\nNow imagine that this string was sent to two other users, who concurrently appended\n`\" joy\"` and `\"on\"` to it. Then those users would send their operations back to\nuser 1, which will use the remote `.ins()` method to apply those operations, lets\ndo that:\n\n```ts\n// User 2 and 3 insert their changes at the same time \"ts(user1, 2)\"\nstr1.ins(ts(user1, 2), ts(user2, 3), ' joy');\nstr1.ins(ts(user1, 2), ts(user3, 3), 'on');\n\nconsole.log(str1 + '');\n// StringRga 123.0 { \"json joy\" }\n// └─ StringChunk 789.3!2 len:8 { \"on\" }\n//    ← StringChunk 123.1!2 len:2 { \"js\" }\n//    → StringChunk 345.3!4 len:4 { \" joy\" }\n```\n\nThe final string is `\"json joy\"`. You can see that `.ins()` first inserted `\" joy\"`\nand then `\"on\"`, lets try to reverse the order and see if we still get the same\nresult:\n\n```ts\n// User 1 creates a new string \"js\"\nconst str2 = new StringRga(ts(user1, 0));\nstr2.insAt(0, ts(user1, 1), 'js');\n\n// User 2 and 3 insert their changes at the same time \"ts(user1, 2)\"\nstr2.ins(ts(user1, 2), ts(user3, 3), 'on');\nstr2.ins(ts(user1, 2), ts(user2, 3), ' joy');\n\nconsole.log(str2 + '');\n// StringRga 123.0 { \"json joy\" }\n// └─ StringChunk 345.3!4 len:8 { \" joy\" }\n//    ← StringChunk 789.3!2 len:4 { \"on\" }\n//      ← StringChunk 123.1!2 len:2 { \"js\" }\n```\n\nAgain, we get the `\"json joy\"` final result. The reason that results are the same\nin both cases is because we use the unique character IDs to order the inserts.\nUser 3 has site ID `789`, but user User 2 has `345`, hence for conflict\nconcurrent inserts User 3's inserts will appear to the left of User 2's inserts.\nNo magic here, that is just how CT/RGA algorithm is specified.\n\n\n## The Block-wise CT/RGA-Split Splay Rope with Identifier Table\n\nThe `json-joy` RGA implementation is very fast, we will see that in the next section.\nBut in this section we will take a look at the data structure that powers the\n`StringRga` class. The `StringRga` class is fast because it uses a custom\nstate-of-the-art data structure that is specifically designed for the\nRGA algorithm. It implements what can be describe as\n*Block-wise CT/RGA-Split Rope with Identifier Table* algorithm. It is\na mouthful, but the purpose of this section is to decipher it for the reader.\n\n- **Block-wise** means that the text is stored in blocks (`StringChunk` in `json-joy`),\n  where each block contains a small metadata piece, instead of storing each character\n  separately, with metadata allocated for each character. This is a well known technique\n  in academia, however, it is not commonly used in practice, because it is\n  difficult to implement. The canonical RGA algorithm is just a linked list of\n  single characters, which is very easy to implement, but it is not efficient.\n  Block-wise representation is more efficient, but it is more difficult to implement,\n  as implicitly each character still has a unique ID and can be referenced by that ID.\n  So, the blocks can be split and merged, which requires a lot of bookkeeping.\n- **CT/RGA** simply means that the base algorithm is *Causal Trees/Replicated Growable Array*.\n  This is currently the best known algorithm for list (strings, arrays) CRDTs, it\n  has formal proofs of correctness, it is efficient, and is probably most cited\n  list CRDT algorithm in academic papers.\n- **Split** refers to the optimization described in the\n  [*\"High Responsiveness for Group Editing CRDTs\"* (Briot et al., 2006) paper][high-responsiveness-crdts],\n  a \"split link\" is stored to the the other part of the block that was split. This allows\n  to perform search and delete operations on blocks more efficiently, when the block was\n  split.\n- **Splay Rope** means that the RGA blocks are stored in a rope-like binary splay tree.\n  Unlike the canonical RGA algorithm, where the blocks are stored in a linked list.\n  This allows for faster than `O(log n)` lookups of text by position.\n- **Identifier Table** is another splay tree, which stores the mapping of character IDs\n  to the blocks. This allows to perform lookups of characters by ID in less than\n  `O(log n)` time.\n\nA novelty of the `json-joy` implementation is that it uses Splay trees for both\nthe Chunk Rope and the Identifier Table. In practice this results into a very fast\ntree traversals, because the trees are splayed on every insert, which results into\n*likely* faster than `O(log n)` access time, for all operations, as users usually:\n(1) type multiple characters at the same position (for the Text Rope); and\n(2) reference the most recent IDs (for the Identifier Table). When the trees are\nun-serialized from storage, they can be balanced, which results into *exactly*\n`O(log n)` complexity, for all operations for freshly hydrated trees (say, when\nopening the document from a file).\n\nThere are many more minor optimizations that make `json-joy` fast, but another one\nworth mentioning is the insert in the middle of the block situation described in\n[(Briot et al., 2006)][high-responsiveness-crdts], which results\ninto two block splits. The insert is performed such that the new block is rotated\nto the top, while the other two blocks are rotated to the bottom.\n\n![insert-into-middle-of-block](https://streamich.github.io/json-joy/blog/images/blockwise-middle-split.png)\n\nLets look at an example of how this all works together.\n\n\n### Block-wise CT/RGA-Split Rope with Identifier Table Example\n\nThis will be a simple example, which showcases a single insert. We will start with\na string `\"GG WP\"` and insert `\"OOD \"` in the middle of it. The final string will\nbe `\"GOOD G WP\"`.\n\nStrings are represented by the RGA algorithm, so the simplest way of thinking about\nit is to imagine the starting string as a linked list of characters, where each\ncharacter has a unique ID.\n\n![RGA string](https://streamich.github.io/json-joy/blog/images/blogpost-001/rga-string.png)\n\nA collaborative editing expert will notice that:\n\n- At least two users `a` and `c` have edited the string.\n  - User `a` inserted `\"GGWP\"`.\n  - User `c` inserted the space `\" \"`.\n- Also, the `a.3` and `c.3` edits were made concurrently, which means that user `a`\n  inserted `\"WP\"` and user `c` inserted `\" \"` at the same time.\n\nThose are not important trivia, now lets look at the same string, but represented\nas a Block-wise RGA. In Block-wise RGA we don't waste memory on storing each\ncharacter separately, instead we store the characters in blocks. Each block has\na unique ID, which is the ID of the first character in the block. The blocks are\nlinked together in a linked list.\n\n![Single character vs block-wise representation](https://streamich.github.io/json-joy/blog/images/blogpost-001/single-char-vs-blockwise.png)\n\nEach character still has a unique ID, it is just the memory is not used to store\nmetadata about characters `a.2` and `a.4`.\n\nWe will insert another block in the middle of an existing block, which will result\ninto a block split. The `\"OOD \"` block with ID `d.5` will be inserted in between the two\n`\"G\"` characters. (Note that `d` means that it is yet another user, and each character in\nthe `d.5` block still implicitly has an ID, which are `d.5`, `d.6`, `d.7`, `d.8`.)\n\n![Block insert](https://streamich.github.io/json-joy/blog/images/blogpost-001/block-insert.png)\n\nBlock-wise representation is our first optimization, lets look at the second one.\nThe second important optimization is that we don't store the blocks in a linked\nlist, instead we store them in a binary tree, or more specifically in a [Rope][rope].\nSo, a little more precisely, the situation could look like this:\n\n![Text Rope tree](https://streamich.github.io/json-joy/blog/images/blogpost-001/text-rope-tree.png)\n\nNote, in the tree we see that there are two tombstones `b.1` and `b.2`, which means\nit used to be text which was inserted concurrently with `a.1`, but was deleted. Also, there\nis a *split link\" between the `b.1` and `b.2` blocks, which means that the `a.1` block was\ninserted in the middle of the `b.1` block, before `b.1` and `b.2` were deleted. The fact\nthat `b` nodes are deleted now is not important, but it is important to note that we keep\ntrack of split links, which allow for faster traversal of the tree.\n\nNow that we know the general setup, lets look at the actual insert, through a series\nof a three step process. First, we need to split the `\"GG\"` block, which is done by\ninserting a new block with ID `a2`.\n\n![Insert step 1](https://streamich.github.io/json-joy/blog/images/blogpost-001/insert-step-1.png)\n\nIn the process a new split link `s3` is created, this will allow for faster traversal, for example,\nwhen somebody will want to delete both `\"GG\"` characters, we will not need to traverse the\nwhole tree to find the second `\"G\"` character, we will just follow the split link `s3` to\nthe second `\"G\"` character. Also, note that when serializing the tree, we can remove all the\nsplit links, because we can reconstruct them on the fly, when de-serializing the tree.\n\nSecond, we need to insert the `\"OOD \"` block, which is done by inserting a new block with\nthe ID `d.5`.\n\n![Insert step 2](https://streamich.github.io/json-joy/blog/images/blogpost-001/insert-step-2.png)\n\nFinally, we perform rotations such that the new block `d.5` is rotated to the top, while\nthe `a.1` and `a.2` blocks are rotated to the bottom.\n\n![Insert step 3](https://streamich.github.io/json-joy/blog/images/blogpost-001/insert-step-3.png)\n\nNow the example above is a bit simplified, because in reality we have two trees, one for\nthe Text Rope and one for the Identifier Table. Actually, for optimization purposes the same\nnodes are used in both trees, so the trees are not separate, but rather they are different\nsorted views of the same data, but that is an implementation detail. The important thing is\nthat we have two trees, one for the Text Rope and one for the Identifier Table, and here is\nhow both trees conceptually look like:\n\n![Example with Identifier Table](https://streamich.github.io/json-joy/blog/images/blogpost-001/with-identifier-table.png)\n\nNote that in both trees the newly inserted blocks are rotated to the top of the trees, which\nfor typical user interactions is a good thing. Users type sequentially whole sentences at a time.\nRotating recently accessed content to the top often leads to less then `O(log n)` insertion time\nfor the next character, because the next character is likely to be inserted in the same block\nas the previous character, which is already at the top of the tree.\n\nAnd this leads to the final optimization that I will mention: merging blocks. When a user\ntypes a whole word, or a sentence, or a paragraph sequentially, we do not create a new block\nfor each character. Instead, a new block is created only when user changes the cursor position.\nSo, if a user types a whole word, or a sentence, or a paragraph sequentially, we will create\na single block for the whole word, or sentence, or paragraph. This is done by merging the\nblocks with adjacent IDs.\n\n![Character merging into block](https://streamich.github.io/json-joy/blog/images/blogpost-001/char-merging.png)\n\n\n## Benchmarks\n\nIn this section we will benchmark `json-joy` implementation of `StringRga` against other\nlibraries. For that, lets first take a look at the datasets wi will use for benchmarking.\n\n\n### Datasets\n\nThere will be no micro benchmarks, only real world large text documents will be tested. Five\nrealistic relatively long text documents will be used.\n\n- The first one is the editing trace of this blog post, yes, the one you are reading now! It is\n  called `json-joy-crdt`, the trace contains all inserts and deletes made to type this blog\n  post. The trace was collected using the [`vscode-tracker`][vscode-tracker] VS Code extension.\n- The other four traces are taken from the [CRDT benchmarks][crdt-benchmarks] repository, see this\n  [description and license information](https://github.com/josephg/crdt-benchmarks/blob/7b0b90e912cfa88aff8c6336917343ee08653e51/README.md#data-sets).\n  - The first trace is the canonical `automerge-paper` trace, made by Martin Kleppmann, the author\n    of the [Automerge][automerge] library. The editing trace was collected while writing the\n    [\"A Conflict-Free Replicated JSON Datatype\" paper](https://arxiv.org/abs/1608.03960). It\n    contains 259,778 single character insert/delete operations, with the final document size\n    of 104,852 bytes, which results in 12,387 `json-joy` RGA blocks in the tree.\n  - The second one is `seph-blog1` trace, which is a trace by Seph Gentle collected while writing\n    the [\"5000x faster CRDTs: An Adventure in Optimization\"][seph-blog1] blog post. The trace contains\n    137,154 insert/delete operations, with the final document size of 56,769 bytes, which results\n    in 18,222 `json-joy` RGA blocks in the tree.\n  - The third one is `rustcode`. It contains 36,981\n    insert/delete operations, with the final document size of 65,218 bytes, which results in\n    12,505 `json-joy` RGA blocks in the tree.\n  - The last one is `sveltecomponent`, it contains 18,335 insert/delete operations, with the\n    final document size of 18,451 bytes, which results in 5,813 `json-joy` RGA blocks in\n    the tree.\n\nEach dataset contains a list of insert or delete operations, each operations specifies the position\nin the document and whether text needs to be inserted or deleted at that position.\n\nHere is the sample of the first operations of the `automerge-paper` editing trace:\n\n```js\n[\n  [ 0, 0, '\\\\' ],  [ 1, 0, 'd' ],   [ 2, 0, 'o' ],   [ 3, 0, 'c' ],\n  [ 4, 0, 'u' ],   [ 5, 0, 'm' ],   [ 6, 0, 'e' ],   [ 7, 0, 'n' ],\n  [ 8, 0, 't' ],   [ 9, 0, 'c' ],   [ 10, 0, 'l' ],  [ 11, 0, 'a' ],\n  [ 12, 0, 's' ],  [ 13, 0, 's' ],  [ 14, 0, '[' ],  [ 15, 0, 'a' ],\n  [ 16, 0, '4' ],  [ 17, 0, 'p' ],  [ 18, 0, 'a' ],  [ 19, 0, 'p' ],\n  [ 20, 0, 'e' ],  [ 21, 0, 'r' ],  [ 22, 0, ',' ],  [ 23, 0, 't' ],\n  [ 24, 0, 'w' ],  [ 25, 0, 'o' ],  [ 26, 0, 'c' ],  [ 27, 0, 'o' ],\n  [ 28, 0, 'l' ],  [ 29, 0, 'u' ],  [ 30, 0, 'm' ],  [ 31, 0, 'n' ],\n  [ 32, 0, ',' ],  [ 33, 0, '1' ],  [ 34, 0, '0' ],  [ 35, 0, 'p' ],\n  [ 36, 0, 't' ],  [ 37, 0, ']' ],  [ 38, 0, '{' ],  [ 39, 0, 'a' ],\n  [ 40, 0, 'r' ],  [ 41, 0, 't' ],  [ 42, 0, 'i' ],  [ 43, 0, 'c' ],\n  [ 44, 0, 'l' ],  [ 45, 0, 'e' ],  [ 46, 0, '}' ],  [ 47, 0, '\\n' ],\n  [ 48, 0, '\\\\' ], [ 49, 0, 'u' ],  [ 50, 0, 's' ],  [ 51, 0, 'e' ],\n  [ 52, 0, 'p' ],  [ 53, 0, 'a' ],  [ 54, 0, 'c' ],  [ 55, 0, 'k' ],\n  [ 56, 0, 'a' ],  [ 57, 0, 'g' ],  [ 58, 0, 'e' ],  [ 59, 0, '{' ],\n  [ 59, 1, '' ],   [ 59, 0, '[' ],  [ 60, 0, 'u' ],  [ 61, 0, 't' ],\n  [ 62, 0, 'f' ],  [ 63, 0, '8' ],  [ 64, 0, ']' ],  [ 65, 0, '{' ],\n  [ 66, 0, 'i' ],  [ 67, 0, 'n' ],  [ 68, 0, 'p' ],  [ 69, 0, 'u' ],\n  [ 70, 0, 't' ],  [ 71, 0, 'e' ],  [ 72, 0, 'n' ],  [ 73, 0, 'c' ],\n  [ 74, 0, '}' ],  [ 75, 0, '\\n' ], [ 76, 0, '\\\\' ], [ 77, 0, 'u' ],\n  [ 78, 0, 's' ],  [ 79, 0, 'e' ],  [ 80, 0, 'p' ],  [ 81, 0, 'a' ],\n  [ 82, 0, 'c' ],  [ 83, 0, 'k' ],  [ 84, 0, 'a' ],  [ 85, 0, 'g' ],\n  [ 86, 0, 'e' ],  [ 87, 0, '{' ],  [ 88, 0, 'm' ],  [ 89, 0, 'a' ],\n  [ 90, 0, 't' ],  [ 91, 0, 'h' ],  [ 92, 0, 'p' ],  [ 93, 0, 't' ],\n  [ 94, 0, 'm' ],  [ 95, 0, 'x' ],  [ 96, 0, '}' ],  [ 97, 0, ' ' ],\n```\n\nEach operation is a 3-tuple which contains: (1) the position in the document; (2) the length of\nthe text to be deleted; and (3) the text to be inserted at that position.\n\n\n### Benchmarks against CRDT libraries\n\nFirst we will benchmark `json-joy` against a peer group of other CRDT libraries:\n\n- [Automerge][automerge] is probably the best known RGA algorithm implementation in JavaScript.\n- [Y.js][yjs] is the most widely used JavaScript CRDT library, which implements YATA algorithm.\n- [Y.rs][yrs] is a port of Y.js to Rust. We use the `ywasm` package, which is a WebAssembly\n  module compiled from its Rust code.\n\nBelow is a sample output of running the benchmarks, numbers are in milliseconds it took to\nexecute the full trace:\n\n\n```\n============================================================================\nEditing trace: \"sveltecomponent\" , Transactions: 18335 , End length: 18451\n----------------------------------------------------------------------------\nAutomerge\n#1: 7325.6\n#2: 7281\n#3: 7286.3\nCorrect: false Length: 18451 Chunks: 0\nBest: 7281 Worst: 7325.6 Average: 7297.6 Tx/sec: 2,512\n----------------------------------------------------------------------------\nY.js\n#1: 381.2\n#2: 358.6\n#3: 360.1\nCorrect: true Length: 18451 Chunks: 4627\nBest: 358.6 Worst: 381.2 Average: 366.6 Tx/sec: 50,008\n----------------------------------------------------------------------------\nY.rs\n#1: 272.5\n#2: 256.6\n#3: 255.9\nCorrect: true Length: 18451 Chunks: 0\nBest: 255.9 Worst: 272.5 Average: 261.7 Tx/sec: 70,071\n----------------------------------------------------------------------------\nStringRga (json-joy)\n#1: 19.1\n#2: 8.1\n#3: 6.2\nCorrect: true Length: 18451 Chunks: 5813\nBest: 6.2 Worst: 19.1 Average: 11.1 Tx/sec: 1,650,406\n\n\n============================================================================\nEditing trace: \"seph-blog1\" , Transactions: 137154 , End length: 56769\n----------------------------------------------------------------------------\nAutomerge\n#1: 20531.4\n#2: 22141.3\n#3: 20786.2\nCorrect: false Length: 56769 Chunks: 0\nBest: 20531.4 Worst: 22141.3 Average: 21153 Tx/sec: 6,484\n----------------------------------------------------------------------------\nY.js\n#1: 2661\n#2: 2664.9\n#3: 2652.8\nCorrect: true Length: 56769 Chunks: 15092\nBest: 2652.8 Worst: 2664.9 Average: 2659.5 Tx/sec: 51,571\n----------------------------------------------------------------------------\nY.rs\n#1: 4534.2\n#2: 4411.7\n#3: 4488.2\nCorrect: false Length: 56777 Chunks: 0\nBest: 4411.7 Worst: 4534.2 Average: 4478.1 Tx/sec: 30,628\n----------------------------------------------------------------------------\nStringRga (json-joy)\n#1: 23.7\n#2: 24.8\n#3: 22.9\nCorrect: true Length: 56769 Chunks: 18222\nBest: 22.9 Worst: 24.8 Average: 23.8 Tx/sec: 5,763,130\n\n\n============================================================================\nEditing trace: \"rustcode\" , Transactions: 36981 , End length: 65218\n----------------------------------------------------------------------------\nY.js\n#1: 720\n#2: 717.4\n#3: 710.7\nCorrect: true Length: 65218 Chunks: 10044\nBest: 710.7 Worst: 720 Average: 716 Tx/sec: 51,647\n----------------------------------------------------------------------------\nY.rs\n#1: 856.8\n#2: 862.2\n#3: 857.9\nCorrect: false Length: 65235 Chunks: 0\nBest: 856.8 Worst: 862.2 Average: 859 Tx/sec: 43,053\n----------------------------------------------------------------------------\nStringRga (json-joy)\n#1: 19.4\n#2: 17.9\n#3: 12.5\nCorrect: true Length: 65218 Chunks: 12505\nBest: 12.5 Worst: 19.4 Average: 16.6 Tx/sec: 2,225,405\n\n\n============================================================================\nEditing trace: \"automerge-paper\" , Transactions: 259778 , End length: 104852\n----------------------------------------------------------------------------\nY.js\n#1: 4787.8\n#2: 4740\n#3: 4739.7\nCorrect: true Length: 104852 Chunks: 10971\nBest: 4739.7 Worst: 4787.8 Average: 4755.8 Tx/sec: 54,623\n----------------------------------------------------------------------------\nY.rs\n#1: 5923.9\n#2: 5869.7\n#3: 5904.8\nCorrect: true Length: 104852 Chunks: 0\nBest: 5869.7 Worst: 5923.9 Average: 5899.5 Tx/sec: 44,034\n----------------------------------------------------------------------------\nStringRga (json-joy)\n#1: 98.6\n#2: 49.6\n#3: 45.9\nCorrect: true Length: 104852 Chunks: 12387\nBest: 45.9 Worst: 98.6 Average: 64.7 Tx/sec: 4,014,031\n```\n\nNotable observations:\n\n- Automerge participated only it the first two traces, as it was not able to handle the\n  larger traces.\n- Y.js is about 10x faster than Automerge.\n- Y.rs is slower than Y.js in all benchmarks, but `sveltecomponent`, which is the smallest\n  trace.\n- `json-joy` is about 50-100x faster than Y.js and 1,000x faster than Automerge.\n\nY.rs implementation might have bugs, as in the above benchmarks it produces correct results\nin only 2 out of 5 traces.\n\n\n### Benchmarks against non-CRDT libraries\n\n`json-joy` RGA implementation i\n\n- `V8 strings` is a benchmark against native JavaScript strings, which are implemented in V8\n  JavaScript engine. It just uses `String.prototype.slice()` to perform insert and delete operations.\n- `rope.js` is a JavaScript library which implements a rope data structure, it is very fast\n  for large strings.\n- `diamond-types-node` is a WebAssembly module of a highly optimized Rust `diamond-types` library.\n  It appends operation metadata to a log and stores the string contents in a skip list powered by\n  a [very fast][jump-rope-benchmarks] [`JumpRope`][jump-rope] library.\n\n\n### A note on Rust fad among CRDT library authors\n\nFirstly, we believe that Rust is a great language and would love to port `json-joy` to Rust some day.\nThis comment is not about the Rust language, but rather about the Rust fad among CRDT library authors.\n\nIt seems there is a pattern of JavaScript CRDT libraries being ported to Rust, and here are the\nexamples:\n\n- [Automerge][automerge] is a JavaScript CRDT library, which has rewritten its lower-level API, what it\n  calls \"backend\", into Rust. Now, the Rust backend is compiled into WebAssembly module and published as\n  `@automerge/automerge-wasm` package, which the `@automerge/automerge` JavaScript\n  code calls into through WebAssembly ABI for all its document operations. But, as you can see from\n  the benchmarks above, Automerge is still 1,000x slower than `json-joy`.\n- [Y.rs][yrs] is a Rust port of a JavaScript CRDT library [Y.js][yrs]. As you can see from the\n  benchmarks above, Y.js is about 100x slower than `json-joy` and the Rust port (which is exposed to\n  JavaScript through WebAssembly `ywasm` package) is about the same speed as the JavaScript version,\n  also about 100x slower than `json-joy`.\n- `diamond-types` is a Rust library which intends to implement various novel CRDT algorithms. It is\n  written by Seph Gentle, the author of numerous JavaScript collaborative editing libraries. The Rust\n  is chosen in search of performance, the library is exposed to JavaScript through WebAssembly ABI from\n  the `diamond-types-node` NPM package.\n\nAs a rule of thumb, an equivalent algorithm implemented in Rust will be about 2-5x faster than the\nsame algorithm implemented in JavaScript. However, when compiling Rust to WebAssembly, it loses about\n3-4x of its performance. So, net-net code ported from JavaScript to Rust and then compiled to WebAssembly\nfor consumption in JavaScript will be about the same speed as the original JavaScript code.\n\nHowever, packaging code into WebAssembly modules has downsides. Firstly, WebAssembly modules limit\nthe data structures one can share between the JavaScript and WebAssembly code.\n\nSecondly, WebAssembly modules result in larger bundle sizes, which is a problem for web applications.\nWASM modules can easily reach 100 KB in size, sometimes even 1 MB. Below are the real-world sizes of the\nWASM modules for the libraries mentioned above:\n\n`@automerge/automerge-wasm` - 1.3 MB\n\n![Character merging into block](https://streamich.github.io/json-joy/blog/images/wasm-sizes/automerge-wasm.png)\n\n`ywasm` - 1 MB\n\n![Character merging into block](https://streamich.github.io/json-joy/blog/images/wasm-sizes/ywasm.png)\n\n`diamond-types-node` - 300 KB\n\n![Character merging into block](https://streamich.github.io/json-joy/blog/images/wasm-sizes/diamond-types-node.png)\n\n\n\n\n\n[rga]: https://www.sciencedirect.com/science/article/abs/pii/S0743731510002716\n[causal-tree]: https://www.researchgate.net/publication/221367739_Deep_hypertext_with_embedded_revision_control_implemented_in_regular_expressions\n[high-responsiveness-crdts]: https://pages.lip6.fr/Marc.Shapiro/papers/rgasplit-group2016-11.pdf\n[rope]: https://en.wikipedia.org/wiki/Rope_(data_structure)\n[crdt-benchmarks]: https://github.com/josephg/crdt-benchmarks\n[datasets]: https://github.com/josephg/crdt-benchmarks/blob/7b0b90e912cfa88aff8c6336917343ee08653e51/README.md#data-sets\n[automerge]: https://github.com/automerge/automerge\n[yrs]: https://github.com/y-crdt/y-crdt\n[yjs]: https://github.com/yjs/yjs\n[vscode-tracker]: https://github.com/josephg/vscode-tracker\n[seph-blog1]: https://josephg.com/blog/crdts-go-brrr/\n[jump-rope]: https://github.com/josephg/jumprope-rs\n[jump-rope-benchmarks]: https://github.com/josephg/jumprope-rs#benchmarks\n"