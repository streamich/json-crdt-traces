"Author: Vadim @streamich Dalecky\nPermalink: https://jsonjoy.com/specs/json-crdt-patch\nPermalink: https://jsonjoy.com/specs/json-crdt-patch\n\n---\n\n# JSON CRDT Patch (working draft)\neamich Dalecky\n\n---\n\n# JSON CRDT Patch (working draft)\n\nPatch protocol specification for JSON CRDT. JSON CRDT Patch is an atomic unit of\nchange for JSON CRDT data structures. A patch is applied as a whole, either all\noperations in the patch are applied, or none of them.\n\nEach patch consists of one or more operations. Each operation is a change to\na single CRDT object. The operations are applied in the order they appear in\nthe patch.\n\n~~~jj.note\n#### Relation to JSON Patch\n\nJSON CRDT Patch is similar to [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902), in the sense that\nboth are patch protocols for JSON document changes. However, JSON Patch is designed for regular JSON documents,\nwhile JSON CRDT Patch specifies a patch specification for JSON CRDT data structures.\n~~~\n\n\n## Data Types\n\nJSON CRDT Patch supports operations on CRDT data types described in JSON CRDT specification.\nThe following data types are supported:\n\n- `con` --- a constant value.\n- `val` --- a LWW-Register.\n- `obj` --- a LWW-Object.\n- `vec` --- a LWW-Vector.\n- `str` --- an RGA-String.\n- `bin` --- an RGA-Binary blob.\n- `arr` --- an RGA-Array.\n\n\n### The `con` Constant\n\nThe `con` data type is a constant value, which does not accept any operations and cannot be changed.\nThe constant value is set at the time of creation of the `con` data type and never changes after that.\nThe only way to change the value of the `con` data type is to delete it from a parent container,\nsuch as an object or an array, and create a new one.\n\nThe value of a `con` data type is a JSON value. The value can be any JSON value, including\n`null`, `true`, `false`, numbers, strings, arrays, objects, binary blobs, `undefined` value,\nand logical clock timestamps.\n\nThe only operation supported by the `con` data type is `new_con`, which creates a new `con` object\nwith a specified value.\n\n\n### The `val` LWW-Register\n\nThe `val` data type is a LWW-Register (Last-Write-Wins Register), which stores a single value.\nThe value is a reference to another CRDT data type. Often it is a reference to `con` object.\n\nThe `val` data type supports the following operations:\n\n- `new_val` - creates a new `val` data type.\n- `ins_val` - updates the value of the `val` data type. The update succeeds only if the ID of the\n  new value is greater than the ID of the current value.\n\nThe `val` data type cannot be deleted, to delete it, it must be removed from the container type,\nsuch as `obj`, `vec`, `arr`, or another `val`.\n\n\n### The `obj` LWW-Object\n\nThe `obj` data type is a LWW-Object (Last-Write-Wins Object), which stores a set of key-value pairs.\nEach key-value pair is a distinct LWW-Register CRDT object. The keys are strings, the values are\nreferences to other CRDT objects.\n\nThe `obj` data type supports the following operations:\n\n- `new_obj` - creates a new `obj` data type.\n- `ins_obj` - inserts or updates key-value pairs in an `obj` object. Each key-value pair is a\n  separate LWW-Register. The update succeeds only if the ID of the new value is greater than\n  the ID of the current value.\n\nTo delete a key-value pair from an `obj` object, the key must be set to `con` object with\n`undefined` value.\n\n\n### The `vec` LWW-Vector\n\nThe `vec` LWW-Vector data type is similar to `obj` LWW-Object. Just like the `obj` data type,\nthe `vec` store a set of key-value pairs. However, the keys in `vec` are integers, which start\nfrom zero and increment by one for each new key-value pair. The maximum key value is limited\nto 255, minimum key value is zero.\n\nThe `vec` data type supports the following operations:\n\n- `new_vec` - creates a new `vec` data type.\n- `ins_vec` - inserts or updates key-value pairs in a `vec` object. Each key-value pair is a\n  separate LWW-Register. The update succeeds only if the ID of the new value is greater than\n  the ID of the current value.\n\nUsually, the `vec` data type is used to store fixed-length arrays, i.e. tuples. Hence, usually\nthe elements of a `vec` object are never deleted. However, it is possible to delete elements\nfrom a `vec` object by setting the value of the element to `con` object with `undefined` value.\n\n\n### The `str` RGA-String\n\nThe `str` data type is a RGA-String (Replicated Growable Array String), which represents a\nUTF-16 string. The `str` data type represents an ordered list of UTF-16 code points. A unit\nof insertion and deletion is a single UTF-16 code point.\n\nThe `str` data type supports the following operations:\n\n- `new_str` - creates a new `str` data type.\n- `ins_str` - inserts a sub-string into a `str` object. The string is inserted at a specified\n  position in the `str` object according to the RGA algorithm.\n- `del` - deletes a sub-string from a `str` object.\n\n\n### The `bin` RGA-Binary\n\nThe `bin` data type is a RGA-Binary (Replicated Growable Array Binary), which represents an\nordered list of octets. The `bin` data type is similar to the `str` data type, except that\na unit of insertion and deletion is an octet, not a character.\n\nThe `bin` data type supports the following operations:\n\n- `new_bin` - creates a new `bin` data type.\n- `ins_bin` - inserts a chunk of binary data into a `bin` object. The chunk is inserted at a specified\n  position in the `bin` object according to the RGA algorithm.\n- `del` - deletes a chunk of binary data from a `bin` object.\n\n\n### The `arr` RGA-Array\n\nThe `arr` data type is a RGA-Array (Replicated Growable Array), which represents an ordered list\nof CRDT objects. The `arr` data type is similar to the `str` and `bin` data types, except that\na unit of insertion and deletion is a reference to another CRDT object, not a character or an octet.\n\nThe `arr` data type supports the following operations:\n\n- `new_arr` - creates a new `arr` data type.\n- `ins_arr` - inserts one or more elements into an `arr` object following the RGA algorithm.\n- `del` - deletes elements from an `arr` object.\n\nThe `arr` elements are immutable. To update an element, it must be deleted and a new element\nmust be inserted in its place. Alternatively, the element can point to a mutable `val` object,\nwhich can be updated in-place.\n\n\n## Operation Types\n\nJSON CRDT Patch classifies all patch operations into four broad types:\n\n- `new` - creates a new CRDT object.\n- `ins` - updates a CRDT object.\n- `del` - deletes a contents of a CRDT object.\n- `nop` - *noop* operation, operation which does nothing.\n\n\n### The `new` Operation Type\n\nThe `new` operations create new CRDT objects. Usually, they have no other payload.\n\nThe exception are `con` and `val` objects. The `con` and `val` objects are created with a\npayload, which is the initial value of the object. The `con` objects are immutable, but the `val`\n\n\n### The `ins` Operation Type\n\nThe `ins` operations update existing CRDT objects. The payload and semantics of the update depend\non the type of the CRDT object. All `ins` operations reference the ID of the CRDT object they\nupdate.\n\n\n### The `del` Operation Type\n\nThe `del` operations delete contents of existing list CRDT objects. All `del` operations reference\nthe ID of the CRDT object they delete contents from. The `del` operations are uniform --- they\nhave the same payload and semantics for all list CRDT objects.\n\n\n### The `nop` Operation Type\n\n~~~jj.aside\nJSON CRDT Patch encodings do not store IDs for each operation. Instead, only the starting ID of\nthe patch is stored. All subsequent IDs are calculated by incrementing the previous ID by the\nnumber of clock cycles the operation takes. The `nop` operation allows to skip clock cycles.\n~~~\n\nThe `nop` operations do nothing. They are used to skip over logical clock cycles in the patch.\n\n\n## Operations\n\nEach JSON CRDT Patch consists of one or more operations. An operation is an immutable unit of\nchange. Each operation has a unique ID, which is a logical timestamp. Operations might\nalso have a reference to some CRDT object and/or a payload.\n\nIn total, JSON CRDT Patch defines 15 operations, they are:\n\n- `new_con` --- creates a new `con` object.\n- `new_val` --- creates a new `val` object.\n- `new_obj` --- creates a new `obj` object.\n- `new_vec` --- creates a new `vec` object.\n- `new_str` --- creates a new `str` object.\n- `new_bin` --- creates a new `bin` object.\n- `new_arr` --- creates a new `arr` object.\n- `ins_val` --- updates value of a `val` object.\n- `ins_obj` --- inserts or updates key-value pairs of an `obj` object.\n- `ins_vec` --- inserts or updates elements of a `vec` object.\n- `ins_str` --- inserts text contents into a `str` object.\n- `ins_bin` --- inserts binary contents into a `bin` object.\n- `ins_arr` --- inserts elements into an `arr` object.\n- `del` --- deletes contents from list CRDT objects.\n- `nop` --- does nothing.\n\nDepending on the encoding used, a mnemonic or an opcode is used to identify each\noperation. Below table lists all mnemonics:\n\n```\n+===================================================================+\n| Mnemonics                                                         |\n+===================================================================+\n|           | new         | ins         | del         | nop         |\n+-----------+-------------+-------------+-------------+-------------+\n| con       | new_con     |             |             |             |\n| val       | new_val     | ins_val     |             |             |\n| obj       | new_obj     | ins_obj     |             |             |\n| vec       | new_vec     | ins_vec     |             |             |\n| str       | new_str     | ins_str     | del         |             |\n| bin       | new_bin     | ins_bin     | del         |             |\n| arr       | new_arr     | ins_arr     | del         |             |\n| ø         |             |             |             | nop         |\n+-----------+-------------+-------------+-------------+-------------+\n```\n\nIn binary encoding, each operation is identified by a 5-bit opcode.\nBelow table lists all opcodes, the opcodes are represented in binary and\ndecimal values in parentheses:\n\n```\n+===================================================================+\n| Opcodes                                                           |\n+===================================================================+\n|           | new         | ins         | del         | nop         |\n+-----------+-------------+-------------+-------------+-------------+\n| con       | 00_000 (0)  |             |             |             |\n| val       | 00_001 (1)  | 01_001 (9)  |             |             |\n| obj       | 00_010 (2)  | 01_010 (10) |             |             |\n| vec       | 00_011 (3)  | 01_011 (11) |             |             |\n| str       | 00_100 (4)  | 01_100 (12) | 10_000 (16) |             |\n| bin       | 00_101 (5)  | 01_101 (13) | 10_000 (16) |             |\n| arr       | 00_110 (6)  | 01_110 (14) | 10_000 (16) |             |\n| ø         |             |             |             | 10_001 (17) |\n+-----------+-------------+-------------+-------------+-------------+\n```\n\n\n### The `new_con` Operation\n\nThe `new_con` operation creates a new `con` object. The operation has an ID,\nwhich is implicitly computed from the position in the patch. The operation\nconsumes one logical clock cycle.\n\nThe payload of the `new_con` operation is the value of the `con` object, which\ncan be one of the following three options:\n\n1. Any JSON value, including: `null`, booleans, numbers, strings, arrays,\n   objects, and binary blobs.\n2. An `undefined` value, which indicates that the `con` object is empty.\n3. A logical clock value, which is a 2-tuple for integers.\n\n~~~jj.note\nJSON CRDT supports binary data. When binary data is used inside a `con` object,\ncare needs to be taken to ensure that the patch is encoded in a way that\nsupports binary data.\n\nWhen `binary` encoding is used, it will automatically encode the binary data\ncorrectly. When `compact` or `verbose` encoding is used, one needs to use a JSON\nencoding format that supports binary data, such as CBOR or MessagePack.\n~~~\n\n~~~jj.note\nThe `undefined` and logical clock values can only appear at the root of the\n`con` object. They cannot appear inside nested `con` objects. As a result,\nall JSON CRDT Patch encodings supports those values without placing any\naddition restrictions on the `compact` and `verbose` encoding serialization.\n~~~\n\n\n### The `new_val` Operation\n\nThe `new_val` operation creates a new `val` object. The operation has an ID,\nwhich is implicitly computed from the position in the patch. The operation\nconsumes one logical clock cycle.\n\nThe payload of the `new_val` operation is the value of the `val` object, which\nis an ID (logical timestamp) of another JSON CRDT object.\n\n\n### The `new_obj` Operation\n\nThe `new_obj` creates a new `obj` object. The operation has an ID, which is\nimplicitly computed from the position in the patch. The operation consumes one\nlogical clock cycle.\n\n\n### The `new_vec` Operation\n\nThe `new_vec` creates a new `vec` object. The operation has an ID, which is\nimplicitly computed from the position in the patch. The operation consumes one\nlogical clock cycle.\n\n\n### The `new_str` Operation\n\nThe `new_str` creates a new `str` object. The operation has an ID, which is\nimplicitly computed from the position in the patch. The operation consumes one\nlogical clock cycle.\n\n\n### The `new_bin` Operation\n\nThe `new_bin` creates a new `bin` object. The operation has an ID, which is\nimplicitly computed from the position in the patch.\n\nThe operation consumes one logical clock cycle.\n\n\n### The `new_arr` Operation\n\nThe `new_arr` creates a new `arr` object. The operation has an ID, which is\nimplicitly computed from the position in the patch.\n\nThe operation consumes one logical clock cycle.\n\n\n### The `ins_val` Operation\n\nThe `ins_val` operation updates the value of a `val` object. The operation has\nan ID, which is implicitly computed from the position in the patch.\n\nThe `ins_val` operation holds the following payload:\n\n- The ID of a `val` object.\n- The new value of the `val` object.\n\nThe operation consumes one logical clock cycle.\n\n\n### The `ins_obj` Operation\n\nThe `ins_obj` operation inserts or updates key-value pairs of an `obj` object.\nThe operation has an ID, which is implicitly computed from the position in the\npatch.\n\nThe `ins_obj` operation holds the following payload:\n\n- The ID of a `obj` object.\n- The list of elements to be inserted or updated.\n\nThe operation consumes one logical clock cycle.\n\n\n### The `ins_vec` Operation\n\nThe `ins_vec` operation inserts or updates elements of a `vec` object. The\noperation has an ID, which is implicitly computed from the position in the\npatch.\n\nThe `ins_vec` operation holds the following payload:\n\n- The ID of a `vec` object.\n- The list of elements to be inserted or updated.\n\nThe operation consumes one logical clock cycle.\n\n\n### The `ins_str` Operation\n\nThe `ins_str` operation inserts text contents into a `str` object. The\noperation has an ID, which is implicitly computed from the position in the\npatch.\n\nThe `ins_str` operation holds the following payload:\n\n- The ID of a `str` object.\n- The ID of the element after which the text is inserted.\n- The text to be inserted.\n\nThe operation consumes the number of clock cycles equal to the length of the\ninserted text.\n\n\n### The `ins_bin` Operation\n\nThe `ins_bin` operation inserts binary contents into a `bin` object. The\noperation has an ID, which is implicitly computed from the position in the\npatch.\n\nThe `ins_bin` operation holds the following payload:\n\n- The ID of a `bin` object.\n- The ID of the element after which the binary contents are inserted.\n- The binary contents to be inserted.\n\nThe operation consumes the number of clock cycles equal to the length of octets\nin the inserted binary contents.\n\n\n### The `ins_arr` Operation\n\nThe `ins_arr` operation inserts elements into an `arr` object. The operation\nhas an ID, which is implicitly computed from the position in the patch.\n\nThe `ins_arr` operation holds the following payload:\n\n- The ID of an `arr` object.\n- The ID of the element after which the new elements are inserted.\n- The list of elements to be inserted.\n\nThe operation consumes the number of clock cycles equal to the number of\ninserted elements.\n\n\n### The `del` Operation\n\nThe `del` operation deletes contents from RGA ordered list objects, such as\n`str`, `bin`, and `arr`. The operation has an ID, which is implicitly computed\nfrom the position in the patch.\n\nThe `del` operation holds the following payload:\n\n- The ID of an RGA ordered list object.\n- A list of one or more ID ranges to be deleted.\n\nThe operation consumes one logical clock cycle.\n\n\n### The `nop` Operation\n\nThe `nop` operation is a no-op operation, it does nothing. The operation has an ID,\nwhich is implicitly computed from the position in the patch.\n\nThe payload of the `nop` operation is the number of logical clock cycles to\nadvance. Hence, the operation consumes the specified number of logical clock\ncycles.\n\n\n## Summary of Operations\n\nBelow table summarizes the operations defined in the JSON CRDT Patch.\n\n~~~jj.wide\n```\n+======================================================================================================================+\n| Operations                                                                                                           |\n|-----------------------------+----------------------+-------------+---------------------------------------------------+\n|                             | Naming               | Opcode      | Contents                                          |\n|                             +-----+-----+----------+-------+-----+-----+-----------------------------+---------------+\n|                             | Op  | Obj | Mnemonic | Bin   | Dec | Obj | Payload                     | Span          |\n|                             +-----+-----+----------+-------+-----+-----+-----------------------------+---------------+\n| 1   Create new Const        | new | con | new_con  | 00000 | 0   | No  | Value                       | 1             |\n| 2   Create new LWW-Register | new | val | new_val  | 00001 | 1   | No  | Value                       | 1             |\n| 3   Create new LWW-Object   | new | obj | new_obj  | 00010 | 2   | No  | No                          | 1             |\n| 4   Create new LWW-Vector   | new | vec | new_vec  | 00011 | 3   | No  | No                          | 1             |\n| 5   Create new RGA-String   | new | str | new_str  | 00100 | 4   | No  | No                          | 1             |\n| 6   Create new RGA-Binary   | new | bin | new_bin  | 00101 | 5   | No  | No                          | 1             |\n| 7   Create new RGA-Array    | new | arr | new_arr  | 00110 | 6   | No  | No                          | 1             |\n| 8   Update LWW-Register     | ins | val | ins_val  | 01001 | 9   | Yes | New value ID                | 1             |\n| 9   Update LWW-Object       | ins | obj | ins_obj  | 01010 | 10  | Yes | List of [string, ID] tuples | 1             |\n| 10  Update LWW-Vector       | ins | vec | ins_vec  | 01011 | 11  | Yes | List of [number, ID] tuples | 1             |\n| 11  Insert into RGA-String  | ins | str | ins_str  | 01100 | 12  | Yes | After ID, string to insert  | String length |\n| 12  Insert into RGA-Binary  | ins | bin | ins_bin  | 01101 | 13  | Yes | After ID, blob to insert    | Binary length |\n| 13  Insert into RGA-Array   | ins | arr | ins_arr  | 01110 | 14  | Yes | After ID, list of IDs       | List length   |\n| 14  Delete from RGA         | del | del | del      | 10000 | 16  | Yes | List of spans               | 1             |\n| 15  No-op                   | nop | nop | nop      | 10001 | 17  | No  | Length                      | 1+            |\n+----------------------------------------------------------------------------------------------------------------------+\n```\n~~~\n\n\n## Serialization\n\nThe JSON CRDT Patch can be serialized into different formats. The following\nformats are supported:\n\n- `verbose` - a verbose human-readable JSON encoding.\n- `compact` - a JSON encoding which follows Compact JSON encoding scheme.\n- `binary` - a custom designed minimal binary encoding.\n\n\n### The `verbose` Encoding\n\n~~~jj.aside\nThe resulting patch does not have to be encoded as JSON, other JSON-like\nserializers---such as CBOR or MessagePack---can be used as well.\n~~~\n\nThe `verbose` encoding format specifies how JSON CRDT Patch is serialized into\na human-readable JSON-like objects. The patch is represented as a JSON object\nwith the following fields:\n\n- `id` - the ID of the patch. The ID (logical timestamp) of the first operation of the patch. `id` is\n  encoded as an array 2-tuple, where first element is the session ID and the second element is the\n  logical time sequence number.\n- `meta` - optional, the metadata of the patch. This can be any valid JSON object specified by the\n  application.\n- `ops` - the list of operations in the patch. The list is encoded as an array of JSON objects, where\n  each object represents an operation. The ID of each operation is implicitly computed by adding the\n  logical time span of the previous operation to the ID of the previous operation. The first operation\n  of the patch has an ID equal to the ID of the patch.\n\nThe following example shows a patch with two operations:\n\n```json\n{\n  \"id\": [123, 456],\n  \"meta\": { \"author\": \"John Doe\" },\n  \"ops\": [\n    { \"op\": \"new_obj\" },\n    { \"op\": \"new_str\" },\n  ],\n}\n```\n\nPatch operations are encoded as JSON objects. Each operation has an `op` field, which is a string\nequal to the operation mnemonic. Operations, which reference other objects, have an `obj` field,\nwhich is and ID of the referenced object. Operations, which have payload, have a `value` field,\nwhich is the payload of the operation. There maybe be other fields, which are specific to the\noperation, see the operation definitions for details.\n\nID (logical timestamps) can be encoded in one of the following ways:\n\n- As an array 2-tuple, where first element is the session ID and the second element is the logical\n  time sequence number.\n- If the session ID is equal to the session ID of the patch, then the ID can be encoded as a single\n  number, which is the logical time sequence number difference between the ID and the ID of the\n  patch.\n\n\n#### `new_con` Operation Encoding\n\nThe `new_con` operation is encoded as a JSON object with the `\"op\"` field equal to `\"new_con\"`\nand `\"value\"` field equal to the value of the constant.\n\n```json\n{ \"op\": \"new_con\", \"value\": 42 }\n```\n\nA constant with `undefined` value is encoded by omitting the `\"value\"` field.\n\n```json\n{ \"op\": \"new_con\" }\n```\n\nA logical timestamp is encoded by setting the `\"timestamp\"` field to `true`.\n\n```json\n{ \"op\": \"new_con\", \"timestamp\": true, \"value\": [123, 456] }\n```\n\nIf timestamp session ID is equal to the session ID of the patch, then the timestamp can be encoded\nas a single number, which is the logical time sequence number difference between the timestamp and\nthe ID of the patch.\n\n```json\n{ \"op\": \"new_con\", \"timestamp\": 456, \"value\": 0 }\n```\n\n\n#### `new_val` Operation Encoding\n\nThe `new_val` operation is encoded as a JSON object with the `\"op\"` field equal to `\"new_val\"`\nand `\"value\"` field set to the ID (logical timestamp) of the value.\n\nFor example:\n\n```json\n{ \"op\": \"new_val\", \"value\": [123, 456] }\n```\n\nor\n\n```json\n{ \"op\": \"new_val\", \"value\": 42 }\n```\n\n\n#### `new_obj` Operation Encoding\n\nThe `new_obj` operation is encoded as a JSON object with the `\"op\"` field equal to `\"new_obj\"`.\n\n```json\n{ \"op\": \"new_obj\" }\n```\n\n\n#### `new_vec` Operation Encoding\n\nThe `new_vec` operation is encoded as a JSON object with the `\"op\"` field equal to `\"new_vec\"`.\n\n```json\n{ \"op\": \"new_vec\" }\n```\n\n\n#### `new_str` Operation Encoding\n\nThe `new_str` operation is encoded as a JSON object with the `\"op\"` field equal to `\"new_str\"`.\n\n```json\n{ \"op\": \"new_str\" }\n```\n\n\n#### `new_bin` Operation Encoding\n\nThe `new_bin` operation is encoded as a JSON object with the `\"op\"` field equal to `\"new_bin\"`.\n\n```json\n{ \"op\": \"new_bin\" }\n```\n\n\n#### `new_arr` Operation Encoding\n\nThe `new_arr` operation is encoded as a JSON object with the `\"op\"` field equal to `\"new_arr\"`.\n\n```json\n{ \"op\": \"new_arr\" }\n```\n\n\n#### `ins_val` Operation Encoding\n\nThe `ins_val` operation is encoded as a JSON object with the following fields:\n\n- `\"op\"` --- equal to `\"ins_val\"`.\n- `\"obj\"` --- the ID of the `val` object, which value is updated.\n- `\"value\"` --- the ID (logical timestamp) of the new value.\n\nFor example:\n\n```json\n{ \"op\": \"ins_val\", \"obj\": [123, 0], \"value\": [123, 1] }\n```\n\n\n#### `ins_obj` Operation Encoding\n\nThe `ins_obj` operation is encoded as a JSON object with the following fields:\n\n- `\"op\"` --- equal to `\"ins_obj\"`.\n- `\"obj\"` --- the ID of the `obj` object, which value is updated.\n- `\"value\"` --- an array of 2-tuples, where each 2-tuple is a field name and an ID (logical timestamp)\n  of the field value.\n\nAn example where all timestamps are encoded as 2-tuples:\n\n```json\n{\n  \"op\": \"ins_obj\",\n  \"obj\": [123, 0],\n  \"value\": [\n    [\"foo\", [123, 1]],\n    [\"bar\", [123, 2]]\n  ]\n}\n```\n\nSame example, but with timestamps encoded as time differences:\n\n```json\n{\n  \"op\": \"ins_obj\",\n  \"obj\": 1,\n  \"value\": [\n    [\"foo\", 2],\n    [\"bar\", 3]\n  ]\n}\n```\n\n\n#### `ins_vec` Operation Encoding\n\nThe `ins_vec` operation is encoded as a JSON object with the following fields:\n\n- `\"op\"` --- equal to `\"ins_vec\"`.\n- `\"obj\"` --- the ID of the `vec` object, which value is updated.\n- `\"value\"` --- an array of 2-tuples, where each 2-tuple is a position index and an ID (logical timestamp)\n  of the field value.\n\nAn example where all timestamps are encoded as 2-tuples:\n\n```json\n{\n  \"op\": \"ins_vec\",\n  \"obj\": [123, 0],\n  \"value\": [\n    [0, [123, 1]],\n    [1, [123, 2]]\n    [3, [123, 3]]\n  ]\n}\n```\n\nSame example, but with timestamps encoded as time differences:\n\n```json\n{\n  \"op\": \"ins_obj\",\n  \"obj\": 1,\n  \"value\": [\n    [0, 2],\n    [1, 3]\n    [2, 4]\n  ]\n}\n```\n\n\n#### `ins_str` Operation Encoding\n\nThe `ins_str` operation is encoded as a JSON object with the following fields:\n\n- `\"op\"` --- equal to `\"ins_str\"`.\n- `\"obj\"` --- the ID of the `str` object, which value is updated.\n- `\"after\"` --- the ID of the character after which the new sub-string is inserted.\n  If the sub-string is inserted at the beginning of the string, then this field is set to the ID of\n  the `str` object.\n- `\"value\"` --- a sub-string to insert into the `str` object.\n\nFor example:\n\n```json\n{ \"op\": \"ins_str\", \"obj\": [123, 0], \"after\": [123, 1], \"value\": \"foo\" }\n```\n\n\n#### `ins_bin` Operation Encoding\n\nThe `ins_bin` operation is encoded as a JSON object with the following fields:\n\n- `\"op\"` --- equal to `\"ins_bin\"`.\n- `\"obj\"` --- the ID of the `bin` object, which value is updated.\n- `\"after\"` --- the ID of the byte after which the new octets are inserted.\n  If the sub-string is inserted at the beginning of the `bin` object, then this field is set to the ID of\n  the `bin` object.\n- `\"value\"` --- an array of octets to insert into the `bin` object, encoded as Base64 string.\n\nFor example:\n\n```json\n{ \"op\": \"ins_bin\", \"obj\": [123, 0], \"after\": [123, 1], \"value\": \"Zm9v\" }\n```\n\nThe following alphabet is used for Base64 encoding:\n\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\n```\n\nThe padding character is `=`.\n\n\n#### `ins_arr` Operation Encoding\n\nThe `ins_arr` operation is encoded as a JSON object with the following fields:\n\n- `\"op\"` --- equal to `\"ins_arr\"`.\n- `\"obj\"` --- the ID of the `arr` object, which value is updated.\n- `\"after\"` --- the ID of the element after which the new elements are inserted.\n  If the elements are inserted at the beginning of the `arr` object, then this field is set to the ID of\n  the `arr` object.\n- `\"value\"` --- an array of IDs to be inserted into the `arr` object.\n\nFor example:\n\n```json\n{\n  \"op\": \"ins_arr\",\n  \"obj\": [123, 0],\n  \"after\": [123, 1],\n  \"value\": [\n    [123, 2], [123, 3]\n  ]\n}\n```\n\n\n#### `del` Operation Encoding\n\nThe `del` operation is encoded as a JSON object with the following fields:\n\n- `\"op\"` --- equal to `\"del\"`.\n- `\"obj\"` --- the ID of the object in which content is deleted.\n- `\"what\"` --- an array for timespans which specifies RGA ranges to be deleted.\n\nFor example:\n\n```json\n{\n  \"op\": \"del\",\n  \"obj\": [123, 0],\n  \"what\": [\n    [123, 1, 3],\n    [123, 10, 1]\n  ]\n}\n```\n\nA *timespan* represents an interval of logical timestamps, and can be encoded\nin one of the following ways:\n\n- As a 3-tuple `[sessionId, time, length]`, where the `sessionId` and `time` represent\n  the starting point of the timespan, and `length` represents the length of the timespan.\n- When the `sessionId` is the same as the session ID of the patch, it can be omitted.\n  In this case, the timespan is encoded as a 2-tuple `[timeDiff, length]`. Where the first\n  member `timeDiff` is the difference between the starting point of the timespan and the\n  time value of the patch ID.\n\n\n#### `nop` Operation Encoding\n\nThe `nop` operation is encoded as a JSON object with the following fields:\n\n- `\"op\"` --- equal to `\"nop\"`.\n- `\"len\"` --- the number of logical timestamps that are skipped by this operation. This\n  field can be omitted, in which case the value is assumed to be `1`.\n\nFor example:\n\n```json\n{ \"op\": \"nop\", \"len\": 10 }\n```\n\n\n### The `compact` Encoding\n\n~~~jj.aside\nPatches encoded using the `compact` format can be serialized to a very compact binary form using\nbinary JSON encoders, such as CBOR or MessagePack.\n~~~\n\nThe `compact` encoding follows the [Compact JSON encoding scheme](https://jsonjoy.com/specs/compact-json)\nwhich encodes entities as JSON arrays with a special first element that represents the type of the\nentity. This results in a very compact representation of the patch, while still being JSON and human-readable.\n\nA patch consists of a header and a list of operations. The header is a JSON array with the following elements:\n\n- The first element is the ID of the patch, encoded as a JSON 2-tuple array.\n- The second element is an optional metadata object, which can contain any additional application specific\n  information. This field can be omitted.\n\nThe rest of the elements in the patch are operations, encoded according Compact JSON encoding scheme.\n\nBelow is an example of a patch encoded using the `compact` format:\n\n```json\n[\n  [\n    [123, 456], // Patch ID\n    { \"author\": \"John Doe\" }, // Optional metadata\n  ],\n  [1], // \"new_obj\" operation\n  [4]  // \"new_str\" operation\n]\n```\n\n\n#### `new_con` Operation Encoding\n\nThe `new_con` operation is encoded as a JSON array with the starting element `0`.\nThe second element is the value of the constant; and the third element is an optional\nflag that indicates that the constant is a logical timestamp.\n\n```json\n[0, \"foo\"]\n```\n\nA constant with `undefined` value is encoded by omitting the `\"value\"` field.\n\n```json\n[0]\n```\n\nA logical timestamp is encoded by setting the `\"timestamp\"` flag to `true`.\n\n```json\n[0, [123, 456], true]\n```\n\nIf timestamp session ID is equal to the session ID of the patch, then the timestamp can be encoded\nas a single number, which is the logical time sequence number difference between the timestamp and\nthe ID of the patch.\n\n```json\n[0, 10, true]\n```\n\n\n#### `new_val` Operation Encoding\n\nThe `new_val` operation is encoded as a JSON array with the starting element `1`.\nThe second element is the value of the constant.\n\n```json\n[1, [123, 456]]\n```\n\nOr, when relative timestamp is used:\n\n```json\n[1, 10]\n```\n\n\n#### `new_obj` Operation Encoding\n\nThe `new_obj` operation is encoded as a JSON array with a single element `2`.\n\n```json\n[2]\n```\n\n\n#### `new_vec` Operation Encoding\n\nThe `new_vec` operation is encoded as a JSON array with a single element `3`.\n\n```json\n[3]\n```\n\n\n#### `new_str` Operation Encoding\n\nThe `new_str` operation is encoded as a JSON array with a single element `4`.\n\n```json\n[4]\n```\n\n\n#### `new_bin` Operation Encoding\n\nThe `new_bin` operation is encoded as a JSON array with a single element `5`.\n\n```json\n[5]\n```\n\n\n#### `new_arr` Operation Encoding\n\nThe `new_arr` operation is encoded as a JSON array with a single element `6`.\n\n```json\n[6]\n```\n\n\n#### `ins_val` Operation Encoding\n\nThe `ins_val` operation is encoded as a JSON array with the starting element `9`,\nfollowed by the ID of the object in which the value is inserted, and the ID\nof the new value.\n\nFor example:\n\n```json\n[9, [123, 0], [123, 1]]\n```\n\n\n#### `ins_obj` Operation Encoding\n\nThe `ins_obj` operation is encoded as a JSON array with the starting element `10`,\nfollowed by the ID of the object in which the object is inserted, and an array\nof 2-tuples, where each 2-tuple is a field name string and an ID of the new field value.\n\nAn example where all timestamps are encoded as 2-tuples:\n\n```json\n[10, [123, 0], [\n  [\"foo\", [123, 1]],\n  [\"bar\", [123, 2]]\n]]\n```\n\nSame example, but with timestamps encoded as time differences:\n\n```json\n[10, 1, [\n  [\"foo\", 2],\n  [\"bar\", 3]\n]]\n```\n\n\n#### `ins_vec` Operation Encoding\n\nThe `ins_vec` operation is encoded as a JSON array with the starting element `11`,\nfollowed by the ID of the object in which the vector is inserted, and an array\nof 2-tuples, where each 2-tuple is a position index and an ID of the new field value.\n\nAn example where all timestamps are encoded as 2-tuples:\n\n```json\n[11, [123, 0], [\n  [0, [123, 1]],\n  [1, [123, 2]]\n  [3, [123, 3]]\n]]\n```\n\nSame example, but with timestamps encoded as time differences:\n\n```json\n[11, 1, [\n  [0, 2],\n  [1, 3]\n  [3, 4]\n]]\n```\n\n\n#### `ins_str` Operation Encoding\n\nThe `ins_str` operation is encoded as a JSON array with the starting element `12`,\nfollowed by the ID of the object in which the string is inserted, the ID of the\ncharacter after which the new sub-string is inserted, and the new sub-string.\n\nFor example:\n\n```json\n[12, [123, 0], [123, 1], \"foo\"]\n```\n\n\n#### `ins_bin` Operation Encoding\n\nThe `ins_bin` operation is encoded as a JSON array with the starting element `13`,\nfollowed by the ID of the object in which the binary object is inserted, the ID of the\nbyte after which the new octets are inserted, and an array of octets to insert into\nthe binary object, encoded as Base64 string.\n\nFor example:\n\n```json\n[13, [123, 0], [123, 1], \"Zm9v\"]\n```\n\nThe following alphabet is used for Base64 encoding:\n\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\n```\n\nThe padding character is `=`.\n\n\n#### `ins_arr` Operation Encoding\n\nThe `ins_arr` operation is encoded as a JSON array with the starting element `14`,\nfollowed by the ID of the object in which the array is inserted, the ID of the\nelement after which the new elements are inserted, and an array of IDs to be inserted\ninto the array.\n\nFor example:\n\n```json\n[14, [123, 0], [123, 1], [\n  [123, 2],\n  [123, 3]\n]]\n```\n\n\n#### `del` Operation Encoding\n\nThe `del` operation is encoded as a JSON array with the starting element `16`,\nfollowed by the ID of the object in which content is deleted, and an array of\ntimespans which specifies RGA ranges to be deleted.\n\nFor example:\n\n```json\n[16, [123, 0], [\n  [123, 1, 3],\n  [123, 10, 1]\n]]\n```\n\nA *timespan* represents an interval of logical timestamps, and can be encoded\nin one of the following ways:\n\n- As a 3-tuple `[sessionId, time, length]`, where the `sessionId` and `time` represent\n  the starting point of the timespan, and `length` represents the length of the timespan.\n- When the `sessionId` is the same as the session ID of the patch, it can be omitted.\n  In this case, the timespan is encoded as a 2-tuple `[timeDiff, length]`. Where the first\n  member `timeDiff` is the difference between the starting point of the timespan and the\n  time value of the patch ID.\n\n\n#### `nop` Operation Encoding\n\nThe `nop` operation is encoded as a JSON array with the starting element `17`,\nfollowed by an optional length integer. If the length is omitted, it is assumed\nto be `1`.\n\nFor example:\n\n```json\n[17, 10]\n```\n\n\n### The `binary` Encoding\n\nThe `binary` JSON CRDT Patch encoding is not human-readable, but is the most space\nefficient and performant patch encoding.\n\nNumeric values follow big-endian encoding.\n\n\n#### Message encoding\n\nNotation in diagrams:\n\n```\nOne byte:\n+--------+\n|        |\n+--------+\n\nZero or more repeating bytes:\n+........+\n|        |\n+........+\n\nZero or one byte which ends a repeating byte sequence:\n+········+\n|        |\n+········+\n\nVariable number of bytes:\n+========+\n|        |\n+========+\n```\n\n\n#### Patch Structure\n\nThe patch consists of the following elements:\n\n- The patch ID.\n- The patch metadata.\n- The patch operations.\n\n\n##### Patch ID Encoding\n\nThe patch ID is encoded differently depending on whether the patch is using logical clock\nor server clock.\n\n###### Logical Clock\n\nWhen logical clock is used, the patch ID is encoded as follows:\n\n- First, session ID is encoded as `b1vu56`, with flag set to `0`.\n- Then, the timestamp is encoded as a `vu57` integer.\n\n```\n b1vu56(0, sessionId)\n |        vu57(time)\n |        |\n+========+========+\n| b1vu56 |  vu57  |\n+========+========+\n```\n\n\n###### Server Clock\n\nWhen sever clock is used, the patch ID is encoded as `b1vu56` with the flag set to `1`.\n\n```\n b1vu56(1, time)\n |\n+========+\n| b1vu56 |\n+========+\n```\n\n\n##### Operation Encoding\n\nOperations are encoded as follows:\n\n- First, the total number of operations is encoded as a `vu57` integer.\n- Then, each operation is encoded one after another.\n\nEach operation start with *operation header*, which is one ore more bytes. The operation\nheader encodes the operation opcode, and the length of the operation payload. When an\noperation payload does not require a length field, its bits are simply set to `0`.\n\nWhen the length is less than or equal to 7, the header is encoded as a single byte. The\nfirst 3 bits of the byte encode the length, and the remaining 5 bits encode the opcode.\n\n```\n+--------+\n|lllooooo|\n+--------+\n```\n\nWhere `l` is the length, and `o` is the opcode.\n\nWhen the length is greater than 7, the header is encoded as two or more bytes. The first byte\nonly encodes the opcode and all length bits `l` are set to `0`. The following bytes encode\nthe length as a `vu57` integer.\n\n```\n          vu57(length)\n          |\n+--------+========+\n|000ooooo| length |\n+--------+========+\n```\n\n\n###### `new_con` Operation Encoding\n\nThere are two case for the `new_con` operation:\n\n- When the operation payload is a JSON value or `undefined`.\n- When the operation payload is a logical timestamp.\n\n####### When the payload is a JSON value or `undefined`\n\nThe `new_con` operation opcode is encoded as `00000` and the length bits are set to `000`.\nIt is followed by JSON value or `undefined` encoded as CBOR.\n\n```\n+--------+========+\n|00000000|  CBOR  |\n+--------+========+\n```\n\n####### When the payload is a logical timestamp\n\nThe `new_con` operation opcode is encoded as `00000` and the length bits are set to `001`.\nIt is followed by the timestamp encoded as `id`.\n\n```\n+--------+========+\n|00100000|   id   |\n+--------+========+\n```\n\n\n###### `new_val` Operation Encoding\n\nThe `new_val` operation opcode is encoded as `00001` and the length bits are set to `000`.\nThe header byte is followed by the value encoded as `id`.\n\n```\n+--------+========+\n|00000001|   id   |\n+--------+========+\n```\n\n\n###### `new_obj` Operation Encoding\n\nThe `new_obj` operation is encoded as a single byte, where the opcode bits are set to `00010`\nand the length bits are set to `000`.\n\n```\n+--------+\n|00000010|\n+--------+\n```\n\n\n###### `new_vec` Operation Encoding\n\nThe `new_vec` operation is encoded as a single byte, where the opcode bits are set to `00011`\nand the length bits are set to `000`.\n\n```\n+--------+\n|00000011|\n+--------+\n```\n\n\n###### `new_str` Operation Encoding\n\nThe `new_str` operation is encoded as a single byte, where the opcode bits are set to `00100`\nand the length bits are set to `000`.\n\n```\n+--------+\n|00000100|\n+--------+\n```\n\n\n###### `new_bin` Operation Encoding\n\nThe `new_bin` operation is encoded as a single byte, where the opcode bits are set to `00101`\nand the length bits are set to `000`.\n\n```\n+--------+\n|00000101|\n+--------+\n```\n\n\n###### `new_arr` Operation Encoding\n\nThe `new_arr` operation is encoded as a single byte, where the opcode bits are set to `00110`\nand the length bits are set to `000`.\n\n```\n+--------+\n|00000110|\n+--------+\n```\n\n\n###### `ins_val` Operation Encoding\n\nThe `ins_val` operation opcode is encoded as `00101` and the length bits are set to `000`.\nThe header byte is followed by two `id` values, which encode the object being inserted into\nand the value being inserted, respectively.\n\n```\n+--------+========+========+\n|00001001|   id   |   id   |\n+--------+========+========+\n```\n\n\n###### `ins_obj` Operation Encoding\n\nThe `ins_obj` operation opcode is encoded as `01010` and the length encodes the number\nof key-value pairs being inserted. It is followed by the object ID, and the key-value pairs.\n\nThe key-value pairs are encoded as a sequence of key-value pairs, where each key is encoded\nas a CBOR string, and each value is encoded as an `id`.\n\nWhen length is less than or equal to 7, the length is encoded in the first 3 bits of the\nheader byte. The remaining 5 bits are set to `01010`:\n\n```\n+--------+=========+.................+\n|lll01010|   obj   | key-value pairs |\n+--------+=========+.................+\n```\n\nWhen length is greater than 7, the length is encoded as a `vu57` integer:\n\n```\n          vu57(length)\n          |        obj object ID\n          |        |\n+--------+========+=========+.................+\n|00001010|  vu57  |   obj   | key-value pairs |\n+--------+========+=========+.................+\n```\n\nConsider an example when two key-value pairs are inserted into an object:\n\n```\n+--------+=========+========+========+========+========+\n|01001010|   obj   |  CBOR  |   id   |  CBOR  |   id   |\n+--------+=========+========+========+========+========+\n```\n\n\n###### `ins_vec` Operation Encoding\n\nThe `ins_vec` operation opcode is encoded as `01011` and the length encodes the number\nof elements key-value pairs being inserted. It is followed by the vector ID, and the element\nkey-value pairs.\n\nThe element key-value pairs are encoded as a sequence of key-value pairs, where each key is\nencoded as an unsigned 8-bit integer, and each value is encoded as an `id`.\n\nWhen length is less than or equal to 7, the length is encoded in the first 3 bits of the\nheader byte. The remaining 5 bits are set to `01011`:\n\n```\n+--------+=========+.................+\n|lll01011|   obj   | element pairs   |\n+--------+=========+.................+\n```\n\nWhen length is greater than 7, the length is encoded as a `vu57` integer:\n\n```\n          vu57(length)\n          |        vec object ID\n          |        |\n+--------+========+=========+.................+\n|00001011|  vu57  |   obj   | element pairs   |\n+--------+========+=========+.................+\n```\n\n\n###### `ins_str` Operation Encoding\n\nThe `ins_str` operation header opcode is encoded as `01100` and the length encodes the number\nbytes the sub-string consumes in UTF-8 encoding.\n\nThe header is followed by the string ID, and the ID of character after which the sub-string\nis inserted.\n\nFinally, the last component of the operation is the sub-string itself, encoded as a sequence\nof UTF-8 encoded bytes.\n\nWhen length is less than or equal to 7, the length is encoded in the first 3 bits of the\nheader byte. The remaining 5 bits are set to `01100`:\n\n```\n+--------+=========+=========+========+\n|lll01100|   obj   |  after  |  UTF8  |\n+--------+=========+=========+========+\n```\n\nWhen length is greater than 7, the length is encoded as a `vu57` integer:\n\n```\n          vu57(length)\n          |        str object ID\n          |        |         character ID after which to insert\n          |        |         |\n+--------+========+=========+=========+========+\n|00001100|  vu57  |   obj   |  after  |  UTF8  |\n+--------+========+=========+=========+========+\n```\n\n\n###### `ins_bin` Operation Encoding\n\nThe `ins_bin` operation header opcode is encoded as `01101` and the length encodes the number\nbytes being inserted.\n\nThe header is followed by the ID of the `bin` object being inserted into, and the ID of the\nbyte after which binary data is inserted.\n\nFinally, the last component of the operation is the binary data itself, encoded as a sequence\nof bytes.\n\nWhen length is less than or equal to 7, the length is encoded in the first 3 bits of the\nheader byte. The remaining 5 bits are set to `01101`:\n\n```\n+--------+=========+=========+========+\n|lll01101|   obj   |  after  |  data  |\n+--------+=========+=========+========+\n```\n\nWhen length is greater than 7, the length is encoded as a `vu57` integer:\n\n```\n          vu57(length)\n          |        bin object ID\n          |        |         byte ID after which to insert\n          |        |         |\n+--------+========+=========+=========+========+\n|00001101|  vu57  |   obj   |  after  |  data  |\n+--------+========+=========+=========+========+\n```\n\n\n###### `ins_arr` Operation Encoding\n\nThe `ins_arr` operation header opcode is encoded as `01110` and the length encodes the number\nof elements being inserted.\n\nThe header is followed by the ID of the `arr` object being inserted into, and the ID of the\nelement after which elements are inserted.\n\nFinally, the last component of the operation is the elements themselves, encoded as a sequence\nof `id`s.\n\nWhen length is less than or equal to 7, the length is encoded in the first 3 bits of the\nheader byte. The remaining 5 bits are set to `01110`:\n\n```\n+--------+=========+=========+=========+\n|lll01110|   obj   |  after  |   ids   |\n+--------+=========+=========+=========+\n```\n\nWhen length is greater than 7, the length is encoded as a `vu57` integer:\n\n```\n          vu57(length)\n          |        arr object ID\n          |        |         element ID after which to insert\n          |        |         |\n+--------+========+=========+=========+=========+\n|00001110|  vu57  |   obj   |  after  |   ids   |\n+--------+========+=========+=========+=========+\n```\n\n\n###### `del` Operation Encoding\n\nThe `del` operation header opcode is encoded as `10000` and the length encodes the number\nof timespans being deleted.\n\nThe header is followed by a sequence of timespans. Each timespan is encoded as a pair of\n`id` and `vu57` integer. The `id` encodes the start of the timespan, and the `vu57` integer\nencodes the length of the timespan.\n\n```\n+========+========+\n|   id   |  vu57  |\n+========+========+\n```\n\nBelow is an example of a `del` operation that deletes 2 timespans:\n\n```\n+--------+========+========+========+========+\n|01010000|   id   |  vu57  |   id   |  vu57  |\n+--------+========+========+========+========+\n```\n\n\n###### `nop` Operation Encoding\n\nThe `nop` operation header opcode is encoded as `10001` and the length encodes the number\nlogical clock cycles it consumes.\n\nFor example, below encoding shows a `nop` operation that consumes 2 logical clock cycles:\n\n```\n+--------+\n|01010001|\n+--------+\n```\n\n\n##### Patch Metadata Encoding\n\nThe patch metadata is encoded as a JSON object using CBOR encoding. If the metadata is\nempty, it is encoded as a CBOR `undefined` value.\n\n\n#### Encoding Primitives\n\n##### `id` Encoding\n\nThe `id` encodes a logical timestamp.\n\nWhen server clock is used, the `id` is encoded as a `b1vu56`, where the first bit is set\nto `1` to indicate that server clock is used. The remaining 56 bits encode the server\nclock value.\n\nWhen logical clock is used, the `id` is encoded as ...\n\n\n##### `vu57` Variable Length Unsigned 57-bit Integer\n\n- `z` --- variable length unsigned 56 bit integer\n- `?` --- whether the next byte is used for encoding\n\n```\nbyte 1                                                         byte 8\n+--------+........+........+........+........+........+........+········+\n|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|zzzzzzzz|\n+--------+........+........+........+........+........+........+········+\n\n           11111    2211111  2222222  3333332  4443333  4444444 55555555\n  7654321  4321098  1098765  8765432  5432109  2109876  9876543 76543210\n    |                        |                    |             |\n    5th bit of z             |                    |             |\n                             28th bit of z        |             57th bit of z\n                                                  39th bit of z\n```\n\n\n##### `b1vu56` 1-bit Binary Flag + 56-bit Variable Length Unsigned Integer\n\n- `f` --- flag\n- `z` --- variable length unsigned 56 bit integer\n- `?` --- whether the next byte is used for encoding\n\n```\nbyte 1                                                         byte 8\n+--------+........+........+........+........+........+........+········+\n|f?zzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|zzzzzzzz|\n+--------+........+........+........+........+........+........+········+\n\n           1111     2111111  2222222  3333322  4433333  4444444 55555554\n   654321  3210987  0987654  7654321  4321098  1098765  8765432 65432109\n    |                        |                    |             |\n    5th bit of z             |                    |             |\n                             27th bit of z        |             56th bit of z\n                                                  38th bit of z\n```\n"