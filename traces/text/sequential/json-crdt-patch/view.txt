Author: Vadim @streamich Dalecky
Permalink: https://jsonjoy.com/specs/json-crdt-patch
Permalink: https://jsonjoy.com/specs/json-crdt-patch

---

# JSON CRDT Patch (working draft)
eamich Dalecky

---

# JSON CRDT Patch (working draft)

Patch protocol specification for JSON CRDT. JSON CRDT Patch is an atomic unit of
change for JSON CRDT data structures. A patch is applied as a whole, either all
operations in the patch are applied, or none of them.

Each patch consists of one or more operations. Each operation is a change to
a single CRDT object. The operations are applied in the order they appear in
the patch.

~~~jj.note
#### Relation to JSON Patch

JSON CRDT Patch is similar to [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902), in the sense that
both are patch protocols for JSON document changes. However, JSON Patch is designed for regular JSON documents,
while JSON CRDT Patch specifies a patch specification for JSON CRDT data structures.
~~~


## Data Types

JSON CRDT Patch supports operations on CRDT data types described in JSON CRDT specification.
The following data types are supported:

- `con` --- a constant value.
- `val` --- a LWW-Register.
- `obj` --- a LWW-Object.
- `vec` --- a LWW-Vector.
- `str` --- an RGA-String.
- `bin` --- an RGA-Binary blob.
- `arr` --- an RGA-Array.


### The `con` Constant

The `con` data type is a constant value, which does not accept any operations and cannot be changed.
The constant value is set at the time of creation of the `con` data type and never changes after that.
The only way to change the value of the `con` data type is to delete it from a parent container,
such as an object or an array, and create a new one.

The value of a `con` data type is a JSON value. The value can be any JSON value, including
`null`, `true`, `false`, numbers, strings, arrays, objects, binary blobs, `undefined` value,
and logical clock timestamps.

The only operation supported by the `con` data type is `new_con`, which creates a new `con` object
with a specified value.


### The `val` LWW-Register

The `val` data type is a LWW-Register (Last-Write-Wins Register), which stores a single value.
The value is a reference to another CRDT data type. Often it is a reference to `con` object.

The `val` data type supports the following operations:

- `new_val` - creates a new `val` data type.
- `ins_val` - updates the value of the `val` data type. The update succeeds only if the ID of the
  new value is greater than the ID of the current value.

The `val` data type cannot be deleted, to delete it, it must be removed from the container type,
such as `obj`, `vec`, `arr`, or another `val`.


### The `obj` LWW-Object

The `obj` data type is a LWW-Object (Last-Write-Wins Object), which stores a set of key-value pairs.
Each key-value pair is a distinct LWW-Register CRDT object. The keys are strings, the values are
references to other CRDT objects.

The `obj` data type supports the following operations:

- `new_obj` - creates a new `obj` data type.
- `ins_obj` - inserts or updates key-value pairs in an `obj` object. Each key-value pair is a
  separate LWW-Register. The update succeeds only if the ID of the new value is greater than
  the ID of the current value.

To delete a key-value pair from an `obj` object, the key must be set to `con` object with
`undefined` value.


### The `vec` LWW-Vector

The `vec` LWW-Vector data type is similar to `obj` LWW-Object. Just like the `obj` data type,
the `vec` store a set of key-value pairs. However, the keys in `vec` are integers, which start
from zero and increment by one for each new key-value pair. The maximum key value is limited
to 255, minimum key value is zero.

The `vec` data type supports the following operations:

- `new_vec` - creates a new `vec` data type.
- `ins_vec` - inserts or updates key-value pairs in a `vec` object. Each key-value pair is a
  separate LWW-Register. The update succeeds only if the ID of the new value is greater than
  the ID of the current value.

Usually, the `vec` data type is used to store fixed-length arrays, i.e. tuples. Hence, usually
the elements of a `vec` object are never deleted. However, it is possible to delete elements
from a `vec` object by setting the value of the element to `con` object with `undefined` value.


### The `str` RGA-String

The `str` data type is a RGA-String (Replicated Growable Array String), which represents a
UTF-16 string. The `str` data type represents an ordered list of UTF-16 code points. A unit
of insertion and deletion is a single UTF-16 code point.

The `str` data type supports the following operations:

- `new_str` - creates a new `str` data type.
- `ins_str` - inserts a sub-string into a `str` object. The string is inserted at a specified
  position in the `str` object according to the RGA algorithm.
- `del` - deletes a sub-string from a `str` object.


### The `bin` RGA-Binary

The `bin` data type is a RGA-Binary (Replicated Growable Array Binary), which represents an
ordered list of octets. The `bin` data type is similar to the `str` data type, except that
a unit of insertion and deletion is an octet, not a character.

The `bin` data type supports the following operations:

- `new_bin` - creates a new `bin` data type.
- `ins_bin` - inserts a chunk of binary data into a `bin` object. The chunk is inserted at a specified
  position in the `bin` object according to the RGA algorithm.
- `del` - deletes a chunk of binary data from a `bin` object.


### The `arr` RGA-Array

The `arr` data type is a RGA-Array (Replicated Growable Array), which represents an ordered list
of CRDT objects. The `arr` data type is similar to the `str` and `bin` data types, except that
a unit of insertion and deletion is a reference to another CRDT object, not a character or an octet.

The `arr` data type supports the following operations:

- `new_arr` - creates a new `arr` data type.
- `ins_arr` - inserts one or more elements into an `arr` object following the RGA algorithm.
- `del` - deletes elements from an `arr` object.

The `arr` elements are immutable. To update an element, it must be deleted and a new element
must be inserted in its place. Alternatively, the element can point to a mutable `val` object,
which can be updated in-place.


## Operation Types

JSON CRDT Patch classifies all patch operations into four broad types:

- `new` - creates a new CRDT object.
- `ins` - updates a CRDT object.
- `del` - deletes a contents of a CRDT object.
- `nop` - *noop* operation, operation which does nothing.


### The `new` Operation Type

The `new` operations create new CRDT objects. Usually, they have no other payload.

The exception are `con` and `val` objects. The `con` and `val` objects are created with a
payload, which is the initial value of the object. The `con` objects are immutable, but the `val`


### The `ins` Operation Type

The `ins` operations update existing CRDT objects. The payload and semantics of the update depend
on the type of the CRDT object. All `ins` operations reference the ID of the CRDT object they
update.


### The `del` Operation Type

The `del` operations delete contents of existing list CRDT objects. All `del` operations reference
the ID of the CRDT object they delete contents from. The `del` operations are uniform --- they
have the same payload and semantics for all list CRDT objects.


### The `nop` Operation Type

~~~jj.aside
JSON CRDT Patch encodings do not store IDs for each operation. Instead, only the starting ID of
the patch is stored. All subsequent IDs are calculated by incrementing the previous ID by the
number of clock cycles the operation takes. The `nop` operation allows to skip clock cycles.
~~~

The `nop` operations do nothing. They are used to skip over logical clock cycles in the patch.


## Operations

Each JSON CRDT Patch consists of one or more operations. An operation is an immutable unit of
change. Each operation has a unique ID, which is a logical timestamp. Operations might
also have a reference to some CRDT object and/or a payload.

In total, JSON CRDT Patch defines 15 operations, they are:

- `new_con` --- creates a new `con` object.
- `new_val` --- creates a new `val` object.
- `new_obj` --- creates a new `obj` object.
- `new_vec` --- creates a new `vec` object.
- `new_str` --- creates a new `str` object.
- `new_bin` --- creates a new `bin` object.
- `new_arr` --- creates a new `arr` object.
- `ins_val` --- updates value of a `val` object.
- `ins_obj` --- inserts or updates key-value pairs of an `obj` object.
- `ins_vec` --- inserts or updates elements of a `vec` object.
- `ins_str` --- inserts text contents into a `str` object.
- `ins_bin` --- inserts binary contents into a `bin` object.
- `ins_arr` --- inserts elements into an `arr` object.
- `del` --- deletes contents from list CRDT objects.
- `nop` --- does nothing.

Depending on the encoding used, a mnemonic or an opcode is used to identify each
operation. Below table lists all mnemonics:

```
+===================================================================+
| Mnemonics                                                         |
+===================================================================+
|           | new         | ins         | del         | nop         |
+-----------+-------------+-------------+-------------+-------------+
| con       | new_con     |             |             |             |
| val       | new_val     | ins_val     |             |             |
| obj       | new_obj     | ins_obj     |             |             |
| vec       | new_vec     | ins_vec     |             |             |
| str       | new_str     | ins_str     | del         |             |
| bin       | new_bin     | ins_bin     | del         |             |
| arr       | new_arr     | ins_arr     | del         |             |
| ø         |             |             |             | nop         |
+-----------+-------------+-------------+-------------+-------------+
```

In binary encoding, each operation is identified by a 5-bit opcode.
Below table lists all opcodes, the opcodes are represented in binary and
decimal values in parentheses:

```
+===================================================================+
| Opcodes                                                           |
+===================================================================+
|           | new         | ins         | del         | nop         |
+-----------+-------------+-------------+-------------+-------------+
| con       | 00_000 (0)  |             |             |             |
| val       | 00_001 (1)  | 01_001 (9)  |             |             |
| obj       | 00_010 (2)  | 01_010 (10) |             |             |
| vec       | 00_011 (3)  | 01_011 (11) |             |             |
| str       | 00_100 (4)  | 01_100 (12) | 10_000 (16) |             |
| bin       | 00_101 (5)  | 01_101 (13) | 10_000 (16) |             |
| arr       | 00_110 (6)  | 01_110 (14) | 10_000 (16) |             |
| ø         |             |             |             | 10_001 (17) |
+-----------+-------------+-------------+-------------+-------------+
```


### The `new_con` Operation

The `new_con` operation creates a new `con` object. The operation has an ID,
which is implicitly computed from the position in the patch. The operation
consumes one logical clock cycle.

The payload of the `new_con` operation is the value of the `con` object, which
can be one of the following three options:

1. Any JSON value, including: `null`, booleans, numbers, strings, arrays,
   objects, and binary blobs.
2. An `undefined` value, which indicates that the `con` object is empty.
3. A logical clock value, which is a 2-tuple for integers.

~~~jj.note
JSON CRDT supports binary data. When binary data is used inside a `con` object,
care needs to be taken to ensure that the patch is encoded in a way that
supports binary data.

When `binary` encoding is used, it will automatically encode the binary data
correctly. When `compact` or `verbose` encoding is used, one needs to use a JSON
encoding format that supports binary data, such as CBOR or MessagePack.
~~~

~~~jj.note
The `undefined` and logical clock values can only appear at the root of the
`con` object. They cannot appear inside nested `con` objects. As a result,
all JSON CRDT Patch encodings supports those values without placing any
addition restrictions on the `compact` and `verbose` encoding serialization.
~~~


### The `new_val` Operation

The `new_val` operation creates a new `val` object. The operation has an ID,
which is implicitly computed from the position in the patch. The operation
consumes one logical clock cycle.

The payload of the `new_val` operation is the value of the `val` object, which
is an ID (logical timestamp) of another JSON CRDT object.


### The `new_obj` Operation

The `new_obj` creates a new `obj` object. The operation has an ID, which is
implicitly computed from the position in the patch. The operation consumes one
logical clock cycle.


### The `new_vec` Operation

The `new_vec` creates a new `vec` object. The operation has an ID, which is
implicitly computed from the position in the patch. The operation consumes one
logical clock cycle.


### The `new_str` Operation

The `new_str` creates a new `str` object. The operation has an ID, which is
implicitly computed from the position in the patch. The operation consumes one
logical clock cycle.


### The `new_bin` Operation

The `new_bin` creates a new `bin` object. The operation has an ID, which is
implicitly computed from the position in the patch.

The operation consumes one logical clock cycle.


### The `new_arr` Operation

The `new_arr` creates a new `arr` object. The operation has an ID, which is
implicitly computed from the position in the patch.

The operation consumes one logical clock cycle.


### The `ins_val` Operation

The `ins_val` operation updates the value of a `val` object. The operation has
an ID, which is implicitly computed from the position in the patch.

The `ins_val` operation holds the following payload:

- The ID of a `val` object.
- The new value of the `val` object.

The operation consumes one logical clock cycle.


### The `ins_obj` Operation

The `ins_obj` operation inserts or updates key-value pairs of an `obj` object.
The operation has an ID, which is implicitly computed from the position in the
patch.

The `ins_obj` operation holds the following payload:

- The ID of a `obj` object.
- The list of elements to be inserted or updated.

The operation consumes one logical clock cycle.


### The `ins_vec` Operation

The `ins_vec` operation inserts or updates elements of a `vec` object. The
operation has an ID, which is implicitly computed from the position in the
patch.

The `ins_vec` operation holds the following payload:

- The ID of a `vec` object.
- The list of elements to be inserted or updated.

The operation consumes one logical clock cycle.


### The `ins_str` Operation

The `ins_str` operation inserts text contents into a `str` object. The
operation has an ID, which is implicitly computed from the position in the
patch.

The `ins_str` operation holds the following payload:

- The ID of a `str` object.
- The ID of the element after which the text is inserted.
- The text to be inserted.

The operation consumes the number of clock cycles equal to the length of the
inserted text.


### The `ins_bin` Operation

The `ins_bin` operation inserts binary contents into a `bin` object. The
operation has an ID, which is implicitly computed from the position in the
patch.

The `ins_bin` operation holds the following payload:

- The ID of a `bin` object.
- The ID of the element after which the binary contents are inserted.
- The binary contents to be inserted.

The operation consumes the number of clock cycles equal to the length of octets
in the inserted binary contents.


### The `ins_arr` Operation

The `ins_arr` operation inserts elements into an `arr` object. The operation
has an ID, which is implicitly computed from the position in the patch.

The `ins_arr` operation holds the following payload:

- The ID of an `arr` object.
- The ID of the element after which the new elements are inserted.
- The list of elements to be inserted.

The operation consumes the number of clock cycles equal to the number of
inserted elements.


### The `del` Operation

The `del` operation deletes contents from RGA ordered list objects, such as
`str`, `bin`, and `arr`. The operation has an ID, which is implicitly computed
from the position in the patch.

The `del` operation holds the following payload:

- The ID of an RGA ordered list object.
- A list of one or more ID ranges to be deleted.

The operation consumes one logical clock cycle.


### The `nop` Operation

The `nop` operation is a no-op operation, it does nothing. The operation has an ID,
which is implicitly computed from the position in the patch.

The payload of the `nop` operation is the number of logical clock cycles to
advance. Hence, the operation consumes the specified number of logical clock
cycles.


## Summary of Operations

Below table summarizes the operations defined in the JSON CRDT Patch.

~~~jj.wide
```
+======================================================================================================================+
| Operations                                                                                                           |
|-----------------------------+----------------------+-------------+---------------------------------------------------+
|                             | Naming               | Opcode      | Contents                                          |
|                             +-----+-----+----------+-------+-----+-----+-----------------------------+---------------+
|                             | Op  | Obj | Mnemonic | Bin   | Dec | Obj | Payload                     | Span          |
|                             +-----+-----+----------+-------+-----+-----+-----------------------------+---------------+
| 1   Create new Const        | new | con | new_con  | 00000 | 0   | No  | Value                       | 1             |
| 2   Create new LWW-Register | new | val | new_val  | 00001 | 1   | No  | Value                       | 1             |
| 3   Create new LWW-Object   | new | obj | new_obj  | 00010 | 2   | No  | No                          | 1             |
| 4   Create new LWW-Vector   | new | vec | new_vec  | 00011 | 3   | No  | No                          | 1             |
| 5   Create new RGA-String   | new | str | new_str  | 00100 | 4   | No  | No                          | 1             |
| 6   Create new RGA-Binary   | new | bin | new_bin  | 00101 | 5   | No  | No                          | 1             |
| 7   Create new RGA-Array    | new | arr | new_arr  | 00110 | 6   | No  | No                          | 1             |
| 8   Update LWW-Register     | ins | val | ins_val  | 01001 | 9   | Yes | New value ID                | 1             |
| 9   Update LWW-Object       | ins | obj | ins_obj  | 01010 | 10  | Yes | List of [string, ID] tuples | 1             |
| 10  Update LWW-Vector       | ins | vec | ins_vec  | 01011 | 11  | Yes | List of [number, ID] tuples | 1             |
| 11  Insert into RGA-String  | ins | str | ins_str  | 01100 | 12  | Yes | After ID, string to insert  | String length |
| 12  Insert into RGA-Binary  | ins | bin | ins_bin  | 01101 | 13  | Yes | After ID, blob to insert    | Binary length |
| 13  Insert into RGA-Array   | ins | arr | ins_arr  | 01110 | 14  | Yes | After ID, list of IDs       | List length   |
| 14  Delete from RGA         | del | del | del      | 10000 | 16  | Yes | List of spans               | 1             |
| 15  No-op                   | nop | nop | nop      | 10001 | 17  | No  | Length                      | 1+            |
+----------------------------------------------------------------------------------------------------------------------+
```
~~~


## Serialization

The JSON CRDT Patch can be serialized into different formats. The following
formats are supported:

- `verbose` - a verbose human-readable JSON encoding.
- `compact` - a JSON encoding which follows Compact JSON encoding scheme.
- `binary` - a custom designed minimal binary encoding.


### The `verbose` Encoding

~~~jj.aside
The resulting patch does not have to be encoded as JSON, other JSON-like
serializers---such as CBOR or MessagePack---can be used as well.
~~~

The `verbose` encoding format specifies how JSON CRDT Patch is serialized into
a human-readable JSON-like objects. The patch is represented as a JSON object
with the following fields:

- `id` - the ID of the patch. The ID (logical timestamp) of the first operation of the patch. `id` is
  encoded as an array 2-tuple, where first element is the session ID and the second element is the
  logical time sequence number.
- `meta` - optional, the metadata of the patch. This can be any valid JSON object specified by the
  application.
- `ops` - the list of operations in the patch. The list is encoded as an array of JSON objects, where
  each object represents an operation. The ID of each operation is implicitly computed by adding the
  logical time span of the previous operation to the ID of the previous operation. The first operation
  of the patch has an ID equal to the ID of the patch.

The following example shows a patch with two operations:

```json
{
  "id": [123, 456],
  "meta": { "author": "John Doe" },
  "ops": [
    { "op": "new_obj" },
    { "op": "new_str" },
  ],
}
```

Patch operations are encoded as JSON objects. Each operation has an `op` field, which is a string
equal to the operation mnemonic. Operations, which reference other objects, have an `obj` field,
which is and ID of the referenced object. Operations, which have payload, have a `value` field,
which is the payload of the operation. There maybe be other fields, which are specific to the
operation, see the operation definitions for details.

ID (logical timestamps) can be encoded in one of the following ways:

- As an array 2-tuple, where first element is the session ID and the second element is the logical
  time sequence number.
- If the session ID is equal to the session ID of the patch, then the ID can be encoded as a single
  number, which is the logical time sequence number difference between the ID and the ID of the
  patch.


#### `new_con` Operation Encoding

The `new_con` operation is encoded as a JSON object with the `"op"` field equal to `"new_con"`
and `"value"` field equal to the value of the constant.

```json
{ "op": "new_con", "value": 42 }
```

A constant with `undefined` value is encoded by omitting the `"value"` field.

```json
{ "op": "new_con" }
```

A logical timestamp is encoded by setting the `"timestamp"` field to `true`.

```json
{ "op": "new_con", "timestamp": true, "value": [123, 456] }
```

If timestamp session ID is equal to the session ID of the patch, then the timestamp can be encoded
as a single number, which is the logical time sequence number difference between the timestamp and
the ID of the patch.

```json
{ "op": "new_con", "timestamp": 456, "value": 0 }
```


#### `new_val` Operation Encoding

The `new_val` operation is encoded as a JSON object with the `"op"` field equal to `"new_val"`
and `"value"` field set to the ID (logical timestamp) of the value.

For example:

```json
{ "op": "new_val", "value": [123, 456] }
```

or

```json
{ "op": "new_val", "value": 42 }
```


#### `new_obj` Operation Encoding

The `new_obj` operation is encoded as a JSON object with the `"op"` field equal to `"new_obj"`.

```json
{ "op": "new_obj" }
```


#### `new_vec` Operation Encoding

The `new_vec` operation is encoded as a JSON object with the `"op"` field equal to `"new_vec"`.

```json
{ "op": "new_vec" }
```


#### `new_str` Operation Encoding

The `new_str` operation is encoded as a JSON object with the `"op"` field equal to `"new_str"`.

```json
{ "op": "new_str" }
```


#### `new_bin` Operation Encoding

The `new_bin` operation is encoded as a JSON object with the `"op"` field equal to `"new_bin"`.

```json
{ "op": "new_bin" }
```


#### `new_arr` Operation Encoding

The `new_arr` operation is encoded as a JSON object with the `"op"` field equal to `"new_arr"`.

```json
{ "op": "new_arr" }
```


#### `ins_val` Operation Encoding

The `ins_val` operation is encoded as a JSON object with the following fields:

- `"op"` --- equal to `"ins_val"`.
- `"obj"` --- the ID of the `val` object, which value is updated.
- `"value"` --- the ID (logical timestamp) of the new value.

For example:

```json
{ "op": "ins_val", "obj": [123, 0], "value": [123, 1] }
```


#### `ins_obj` Operation Encoding

The `ins_obj` operation is encoded as a JSON object with the following fields:

- `"op"` --- equal to `"ins_obj"`.
- `"obj"` --- the ID of the `obj` object, which value is updated.
- `"value"` --- an array of 2-tuples, where each 2-tuple is a field name and an ID (logical timestamp)
  of the field value.

An example where all timestamps are encoded as 2-tuples:

```json
{
  "op": "ins_obj",
  "obj": [123, 0],
  "value": [
    ["foo", [123, 1]],
    ["bar", [123, 2]]
  ]
}
```

Same example, but with timestamps encoded as time differences:

```json
{
  "op": "ins_obj",
  "obj": 1,
  "value": [
    ["foo", 2],
    ["bar", 3]
  ]
}
```


#### `ins_vec` Operation Encoding

The `ins_vec` operation is encoded as a JSON object with the following fields:

- `"op"` --- equal to `"ins_vec"`.
- `"obj"` --- the ID of the `vec` object, which value is updated.
- `"value"` --- an array of 2-tuples, where each 2-tuple is a position index and an ID (logical timestamp)
  of the field value.

An example where all timestamps are encoded as 2-tuples:

```json
{
  "op": "ins_vec",
  "obj": [123, 0],
  "value": [
    [0, [123, 1]],
    [1, [123, 2]]
    [3, [123, 3]]
  ]
}
```

Same example, but with timestamps encoded as time differences:

```json
{
  "op": "ins_obj",
  "obj": 1,
  "value": [
    [0, 2],
    [1, 3]
    [2, 4]
  ]
}
```


#### `ins_str` Operation Encoding

The `ins_str` operation is encoded as a JSON object with the following fields:

- `"op"` --- equal to `"ins_str"`.
- `"obj"` --- the ID of the `str` object, which value is updated.
- `"after"` --- the ID of the character after which the new sub-string is inserted.
  If the sub-string is inserted at the beginning of the string, then this field is set to the ID of
  the `str` object.
- `"value"` --- a sub-string to insert into the `str` object.

For example:

```json
{ "op": "ins_str", "obj": [123, 0], "after": [123, 1], "value": "foo" }
```


#### `ins_bin` Operation Encoding

The `ins_bin` operation is encoded as a JSON object with the following fields:

- `"op"` --- equal to `"ins_bin"`.
- `"obj"` --- the ID of the `bin` object, which value is updated.
- `"after"` --- the ID of the byte after which the new octets are inserted.
  If the sub-string is inserted at the beginning of the `bin` object, then this field is set to the ID of
  the `bin` object.
- `"value"` --- an array of octets to insert into the `bin` object, encoded as Base64 string.

For example:

```json
{ "op": "ins_bin", "obj": [123, 0], "after": [123, 1], "value": "Zm9v" }
```

The following alphabet is used for Base64 encoding:

```
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
```

The padding character is `=`.


#### `ins_arr` Operation Encoding

The `ins_arr` operation is encoded as a JSON object with the following fields:

- `"op"` --- equal to `"ins_arr"`.
- `"obj"` --- the ID of the `arr` object, which value is updated.
- `"after"` --- the ID of the element after which the new elements are inserted.
  If the elements are inserted at the beginning of the `arr` object, then this field is set to the ID of
  the `arr` object.
- `"value"` --- an array of IDs to be inserted into the `arr` object.

For example:

```json
{
  "op": "ins_arr",
  "obj": [123, 0],
  "after": [123, 1],
  "value": [
    [123, 2], [123, 3]
  ]
}
```


#### `del` Operation Encoding

The `del` operation is encoded as a JSON object with the following fields:

- `"op"` --- equal to `"del"`.
- `"obj"` --- the ID of the object in which content is deleted.
- `"what"` --- an array for timespans which specifies RGA ranges to be deleted.

For example:

```json
{
  "op": "del",
  "obj": [123, 0],
  "what": [
    [123, 1, 3],
    [123, 10, 1]
  ]
}
```

A *timespan* represents an interval of logical timestamps, and can be encoded
in one of the following ways:

- As a 3-tuple `[sessionId, time, length]`, where the `sessionId` and `time` represent
  the starting point of the timespan, and `length` represents the length of the timespan.
- When the `sessionId` is the same as the session ID of the patch, it can be omitted.
  In this case, the timespan is encoded as a 2-tuple `[timeDiff, length]`. Where the first
  member `timeDiff` is the difference between the starting point of the timespan and the
  time value of the patch ID.


#### `nop` Operation Encoding

The `nop` operation is encoded as a JSON object with the following fields:

- `"op"` --- equal to `"nop"`.
- `"len"` --- the number of logical timestamps that are skipped by this operation. This
  field can be omitted, in which case the value is assumed to be `1`.

For example:

```json
{ "op": "nop", "len": 10 }
```


### The `compact` Encoding

~~~jj.aside
Patches encoded using the `compact` format can be serialized to a very compact binary form using
binary JSON encoders, such as CBOR or MessagePack.
~~~

The `compact` encoding follows the [Compact JSON encoding scheme](https://jsonjoy.com/specs/compact-json)
which encodes entities as JSON arrays with a special first element that represents the type of the
entity. This results in a very compact representation of the patch, while still being JSON and human-readable.

A patch consists of a header and a list of operations. The header is a JSON array with the following elements:

- The first element is the ID of the patch, encoded as a JSON 2-tuple array.
- The second element is an optional metadata object, which can contain any additional application specific
  information. This field can be omitted.

The rest of the elements in the patch are operations, encoded according Compact JSON encoding scheme.

Below is an example of a patch encoded using the `compact` format:

```json
[
  [
    [123, 456], // Patch ID
    { "author": "John Doe" }, // Optional metadata
  ],
  [1], // "new_obj" operation
  [4]  // "new_str" operation
]
```


#### `new_con` Operation Encoding

The `new_con` operation is encoded as a JSON array with the starting element `0`.
The second element is the value of the constant; and the third element is an optional
flag that indicates that the constant is a logical timestamp.

```json
[0, "foo"]
```

A constant with `undefined` value is encoded by omitting the `"value"` field.

```json
[0]
```

A logical timestamp is encoded by setting the `"timestamp"` flag to `true`.

```json
[0, [123, 456], true]
```

If timestamp session ID is equal to the session ID of the patch, then the timestamp can be encoded
as a single number, which is the logical time sequence number difference between the timestamp and
the ID of the patch.

```json
[0, 10, true]
```


#### `new_val` Operation Encoding

The `new_val` operation is encoded as a JSON array with the starting element `1`.
The second element is the value of the constant.

```json
[1, [123, 456]]
```

Or, when relative timestamp is used:

```json
[1, 10]
```


#### `new_obj` Operation Encoding

The `new_obj` operation is encoded as a JSON array with a single element `2`.

```json
[2]
```


#### `new_vec` Operation Encoding

The `new_vec` operation is encoded as a JSON array with a single element `3`.

```json
[3]
```


#### `new_str` Operation Encoding

The `new_str` operation is encoded as a JSON array with a single element `4`.

```json
[4]
```


#### `new_bin` Operation Encoding

The `new_bin` operation is encoded as a JSON array with a single element `5`.

```json
[5]
```


#### `new_arr` Operation Encoding

The `new_arr` operation is encoded as a JSON array with a single element `6`.

```json
[6]
```


#### `ins_val` Operation Encoding

The `ins_val` operation is encoded as a JSON array with the starting element `9`,
followed by the ID of the object in which the value is inserted, and the ID
of the new value.

For example:

```json
[9, [123, 0], [123, 1]]
```


#### `ins_obj` Operation Encoding

The `ins_obj` operation is encoded as a JSON array with the starting element `10`,
followed by the ID of the object in which the object is inserted, and an array
of 2-tuples, where each 2-tuple is a field name string and an ID of the new field value.

An example where all timestamps are encoded as 2-tuples:

```json
[10, [123, 0], [
  ["foo", [123, 1]],
  ["bar", [123, 2]]
]]
```

Same example, but with timestamps encoded as time differences:

```json
[10, 1, [
  ["foo", 2],
  ["bar", 3]
]]
```


#### `ins_vec` Operation Encoding

The `ins_vec` operation is encoded as a JSON array with the starting element `11`,
followed by the ID of the object in which the vector is inserted, and an array
of 2-tuples, where each 2-tuple is a position index and an ID of the new field value.

An example where all timestamps are encoded as 2-tuples:

```json
[11, [123, 0], [
  [0, [123, 1]],
  [1, [123, 2]]
  [3, [123, 3]]
]]
```

Same example, but with timestamps encoded as time differences:

```json
[11, 1, [
  [0, 2],
  [1, 3]
  [3, 4]
]]
```


#### `ins_str` Operation Encoding

The `ins_str` operation is encoded as a JSON array with the starting element `12`,
followed by the ID of the object in which the string is inserted, the ID of the
character after which the new sub-string is inserted, and the new sub-string.

For example:

```json
[12, [123, 0], [123, 1], "foo"]
```


#### `ins_bin` Operation Encoding

The `ins_bin` operation is encoded as a JSON array with the starting element `13`,
followed by the ID of the object in which the binary object is inserted, the ID of the
byte after which the new octets are inserted, and an array of octets to insert into
the binary object, encoded as Base64 string.

For example:

```json
[13, [123, 0], [123, 1], "Zm9v"]
```

The following alphabet is used for Base64 encoding:

```
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
```

The padding character is `=`.


#### `ins_arr` Operation Encoding

The `ins_arr` operation is encoded as a JSON array with the starting element `14`,
followed by the ID of the object in which the array is inserted, the ID of the
element after which the new elements are inserted, and an array of IDs to be inserted
into the array.

For example:

```json
[14, [123, 0], [123, 1], [
  [123, 2],
  [123, 3]
]]
```


#### `del` Operation Encoding

The `del` operation is encoded as a JSON array with the starting element `16`,
followed by the ID of the object in which content is deleted, and an array of
timespans which specifies RGA ranges to be deleted.

For example:

```json
[16, [123, 0], [
  [123, 1, 3],
  [123, 10, 1]
]]
```

A *timespan* represents an interval of logical timestamps, and can be encoded
in one of the following ways:

- As a 3-tuple `[sessionId, time, length]`, where the `sessionId` and `time` represent
  the starting point of the timespan, and `length` represents the length of the timespan.
- When the `sessionId` is the same as the session ID of the patch, it can be omitted.
  In this case, the timespan is encoded as a 2-tuple `[timeDiff, length]`. Where the first
  member `timeDiff` is the difference between the starting point of the timespan and the
  time value of the patch ID.


#### `nop` Operation Encoding

The `nop` operation is encoded as a JSON array with the starting element `17`,
followed by an optional length integer. If the length is omitted, it is assumed
to be `1`.

For example:

```json
[17, 10]
```


### The `binary` Encoding

The `binary` JSON CRDT Patch encoding is not human-readable, but is the most space
efficient and performant patch encoding.

Numeric values follow big-endian encoding.


#### Message encoding

Notation in diagrams:

```
One byte:
+--------+
|        |
+--------+

Zero or more repeating bytes:
+........+
|        |
+........+

Zero or one byte which ends a repeating byte sequence:
+········+
|        |
+········+

Variable number of bytes:
+========+
|        |
+========+
```


#### Patch Structure

The patch consists of the following elements:

- The patch ID.
- The patch metadata.
- The patch operations.


##### Patch ID Encoding

The patch ID is encoded differently depending on whether the patch is using logical clock
or server clock.

###### Logical Clock

When logical clock is used, the patch ID is encoded as follows:

- First, session ID is encoded as `b1vu56`, with flag set to `0`.
- Then, the timestamp is encoded as a `vu57` integer.

```
 b1vu56(0, sessionId)
 |        vu57(time)
 |        |
+========+========+
| b1vu56 |  vu57  |
+========+========+
```


###### Server Clock

When sever clock is used, the patch ID is encoded as `b1vu56` with the flag set to `1`.

```
 b1vu56(1, time)
 |
+========+
| b1vu56 |
+========+
```


##### Operation Encoding

Operations are encoded as follows:

- First, the total number of operations is encoded as a `vu57` integer.
- Then, each operation is encoded one after another.

Each operation start with *operation header*, which is one ore more bytes. The operation
header encodes the operation opcode, and the length of the operation payload. When an
operation payload does not require a length field, its bits are simply set to `0`.

When the length is less than or equal to 7, the header is encoded as a single byte. The
first 3 bits of the byte encode the length, and the remaining 5 bits encode the opcode.

```
+--------+
|lllooooo|
+--------+
```

Where `l` is the length, and `o` is the opcode.

When the length is greater than 7, the header is encoded as two or more bytes. The first byte
only encodes the opcode and all length bits `l` are set to `0`. The following bytes encode
the length as a `vu57` integer.

```
          vu57(length)
          |
+--------+========+
|000ooooo| length |
+--------+========+
```


###### `new_con` Operation Encoding

There are two case for the `new_con` operation:

- When the operation payload is a JSON value or `undefined`.
- When the operation payload is a logical timestamp.

####### When the payload is a JSON value or `undefined`

The `new_con` operation opcode is encoded as `00000` and the length bits are set to `000`.
It is followed by JSON value or `undefined` encoded as CBOR.

```
+--------+========+
|00000000|  CBOR  |
+--------+========+
```

####### When the payload is a logical timestamp

The `new_con` operation opcode is encoded as `00000` and the length bits are set to `001`.
It is followed by the timestamp encoded as `id`.

```
+--------+========+
|00100000|   id   |
+--------+========+
```


###### `new_val` Operation Encoding

The `new_val` operation opcode is encoded as `00001` and the length bits are set to `000`.
The header byte is followed by the value encoded as `id`.

```
+--------+========+
|00000001|   id   |
+--------+========+
```


###### `new_obj` Operation Encoding

The `new_obj` operation is encoded as a single byte, where the opcode bits are set to `00010`
and the length bits are set to `000`.

```
+--------+
|00000010|
+--------+
```


###### `new_vec` Operation Encoding

The `new_vec` operation is encoded as a single byte, where the opcode bits are set to `00011`
and the length bits are set to `000`.

```
+--------+
|00000011|
+--------+
```


###### `new_str` Operation Encoding

The `new_str` operation is encoded as a single byte, where the opcode bits are set to `00100`
and the length bits are set to `000`.

```
+--------+
|00000100|
+--------+
```


###### `new_bin` Operation Encoding

The `new_bin` operation is encoded as a single byte, where the opcode bits are set to `00101`
and the length bits are set to `000`.

```
+--------+
|00000101|
+--------+
```


###### `new_arr` Operation Encoding

The `new_arr` operation is encoded as a single byte, where the opcode bits are set to `00110`
and the length bits are set to `000`.

```
+--------+
|00000110|
+--------+
```


###### `ins_val` Operation Encoding

The `ins_val` operation opcode is encoded as `00101` and the length bits are set to `000`.
The header byte is followed by two `id` values, which encode the object being inserted into
and the value being inserted, respectively.

```
+--------+========+========+
|00001001|   id   |   id   |
+--------+========+========+
```


###### `ins_obj` Operation Encoding

The `ins_obj` operation opcode is encoded as `01010` and the length encodes the number
of key-value pairs being inserted. It is followed by the object ID, and the key-value pairs.

The key-value pairs are encoded as a sequence of key-value pairs, where each key is encoded
as a CBOR string, and each value is encoded as an `id`.

When length is less than or equal to 7, the length is encoded in the first 3 bits of the
header byte. The remaining 5 bits are set to `01010`:

```
+--------+=========+.................+
|lll01010|   obj   | key-value pairs |
+--------+=========+.................+
```

When length is greater than 7, the length is encoded as a `vu57` integer:

```
          vu57(length)
          |        obj object ID
          |        |
+--------+========+=========+.................+
|00001010|  vu57  |   obj   | key-value pairs |
+--------+========+=========+.................+
```

Consider an example when two key-value pairs are inserted into an object:

```
+--------+=========+========+========+========+========+
|01001010|   obj   |  CBOR  |   id   |  CBOR  |   id   |
+--------+=========+========+========+========+========+
```


###### `ins_vec` Operation Encoding

The `ins_vec` operation opcode is encoded as `01011` and the length encodes the number
of elements key-value pairs being inserted. It is followed by the vector ID, and the element
key-value pairs.

The element key-value pairs are encoded as a sequence of key-value pairs, where each key is
encoded as an unsigned 8-bit integer, and each value is encoded as an `id`.

When length is less than or equal to 7, the length is encoded in the first 3 bits of the
header byte. The remaining 5 bits are set to `01011`:

```
+--------+=========+.................+
|lll01011|   obj   | element pairs   |
+--------+=========+.................+
```

When length is greater than 7, the length is encoded as a `vu57` integer:

```
          vu57(length)
          |        vec object ID
          |        |
+--------+========+=========+.................+
|00001011|  vu57  |   obj   | element pairs   |
+--------+========+=========+.................+
```


###### `ins_str` Operation Encoding

The `ins_str` operation header opcode is encoded as `01100` and the length encodes the number
bytes the sub-string consumes in UTF-8 encoding.

The header is followed by the string ID, and the ID of character after which the sub-string
is inserted.

Finally, the last component of the operation is the sub-string itself, encoded as a sequence
of UTF-8 encoded bytes.

When length is less than or equal to 7, the length is encoded in the first 3 bits of the
header byte. The remaining 5 bits are set to `01100`:

```
+--------+=========+=========+========+
|lll01100|   obj   |  after  |  UTF8  |
+--------+=========+=========+========+
```

When length is greater than 7, the length is encoded as a `vu57` integer:

```
          vu57(length)
          |        str object ID
          |        |         character ID after which to insert
          |        |         |
+--------+========+=========+=========+========+
|00001100|  vu57  |   obj   |  after  |  UTF8  |
+--------+========+=========+=========+========+
```


###### `ins_bin` Operation Encoding

The `ins_bin` operation header opcode is encoded as `01101` and the length encodes the number
bytes being inserted.

The header is followed by the ID of the `bin` object being inserted into, and the ID of the
byte after which binary data is inserted.

Finally, the last component of the operation is the binary data itself, encoded as a sequence
of bytes.

When length is less than or equal to 7, the length is encoded in the first 3 bits of the
header byte. The remaining 5 bits are set to `01101`:

```
+--------+=========+=========+========+
|lll01101|   obj   |  after  |  data  |
+--------+=========+=========+========+
```

When length is greater than 7, the length is encoded as a `vu57` integer:

```
          vu57(length)
          |        bin object ID
          |        |         byte ID after which to insert
          |        |         |
+--------+========+=========+=========+========+
|00001101|  vu57  |   obj   |  after  |  data  |
+--------+========+=========+=========+========+
```


###### `ins_arr` Operation Encoding

The `ins_arr` operation header opcode is encoded as `01110` and the length encodes the number
of elements being inserted.

The header is followed by the ID of the `arr` object being inserted into, and the ID of the
element after which elements are inserted.

Finally, the last component of the operation is the elements themselves, encoded as a sequence
of `id`s.

When length is less than or equal to 7, the length is encoded in the first 3 bits of the
header byte. The remaining 5 bits are set to `01110`:

```
+--------+=========+=========+=========+
|lll01110|   obj   |  after  |   ids   |
+--------+=========+=========+=========+
```

When length is greater than 7, the length is encoded as a `vu57` integer:

```
          vu57(length)
          |        arr object ID
          |        |         element ID after which to insert
          |        |         |
+--------+========+=========+=========+=========+
|00001110|  vu57  |   obj   |  after  |   ids   |
+--------+========+=========+=========+=========+
```


###### `del` Operation Encoding

The `del` operation header opcode is encoded as `10000` and the length encodes the number
of timespans being deleted.

The header is followed by a sequence of timespans. Each timespan is encoded as a pair of
`id` and `vu57` integer. The `id` encodes the start of the timespan, and the `vu57` integer
encodes the length of the timespan.

```
+========+========+
|   id   |  vu57  |
+========+========+
```

Below is an example of a `del` operation that deletes 2 timespans:

```
+--------+========+========+========+========+
|01010000|   id   |  vu57  |   id   |  vu57  |
+--------+========+========+========+========+
```


###### `nop` Operation Encoding

The `nop` operation header opcode is encoded as `10001` and the length encodes the number
logical clock cycles it consumes.

For example, below encoding shows a `nop` operation that consumes 2 logical clock cycles:

```
+--------+
|01010001|
+--------+
```


##### Patch Metadata Encoding

The patch metadata is encoded as a JSON object using CBOR encoding. If the metadata is
empty, it is encoded as a CBOR `undefined` value.


#### Encoding Primitives

##### `id` Encoding

The `id` encodes a logical timestamp.

When server clock is used, the `id` is encoded as a `b1vu56`, where the first bit is set
to `1` to indicate that server clock is used. The remaining 56 bits encode the server
clock value.

When logical clock is used, the `id` is encoded as ...


##### `vu57` Variable Length Unsigned 57-bit Integer

- `z` --- variable length unsigned 56 bit integer
- `?` --- whether the next byte is used for encoding

```
byte 1                                                         byte 8
+--------+........+........+........+........+........+........+········+
|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|zzzzzzzz|
+--------+........+........+........+........+........+........+········+

           11111    2211111  2222222  3333332  4443333  4444444 55555555
  7654321  4321098  1098765  8765432  5432109  2109876  9876543 76543210
    |                        |                    |             |
    5th bit of z             |                    |             |
                             28th bit of z        |             57th bit of z
                                                  39th bit of z
```


##### `b1vu56` 1-bit Binary Flag + 56-bit Variable Length Unsigned Integer

- `f` --- flag
- `z` --- variable length unsigned 56 bit integer
- `?` --- whether the next byte is used for encoding

```
byte 1                                                         byte 8
+--------+........+........+........+........+........+........+········+
|f?zzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|?zzzzzzz|zzzzzzzz|
+--------+........+........+........+........+........+........+········+

           1111     2111111  2222222  3333322  4433333  4444444 55555554
   654321  3210987  0987654  7654321  4321098  1098765  8765432 65432109
    |                        |                    |             |
    5th bit of z             |                    |             |
                             27th bit of z        |             56th bit of z
                                                  38th bit of z
```
